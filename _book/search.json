[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Fundamentos de programación con R",
    "section": "",
    "text": "Bienvenida\nEste libro …",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "index.html#sección-primera",
    "href": "index.html#sección-primera",
    "title": "Fundamentos de programación con R",
    "section": "Sección primera",
    "text": "Sección primera\nSección rimera",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "index.html#sección-segunda",
    "href": "index.html#sección-segunda",
    "title": "Fundamentos de programación con R",
    "section": "Sección segunda",
    "text": "Sección segunda\nSección segunda\n\n\n\n\n\n\nPrueba\n\n\n\nPor defecto\n\n\n\n\n\n\n\n\nPrueba 2\n\n\n\nSimple\n\n\n\n\n\n\n\n\nPrueba 3\n\n\n\nMinimal",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "1002_introduction.html",
    "href": "1002_introduction.html",
    "title": "\n1  Introducción a la visualización de datos\n",
    "section": "",
    "text": "1.1 Ejemplos de visualización de datos\nAntes de comenzar, vamos a ver una serie de ejemplos de visualizaciones de datos que nos ayudarán a entender la importancia de la visualización de datos y cómo puede ayudarnos a entender mejor la información que nos rodea.",
    "crumbs": [
      "Visualización",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la visualización de datos</span>"
    ]
  },
  {
    "objectID": "1002_introduction.html#ejemplos-de-visualización-de-datos",
    "href": "1002_introduction.html#ejemplos-de-visualización-de-datos",
    "title": "\n1  Introducción a la visualización de datos\n",
    "section": "",
    "text": "1.1.1 Artículos científicos\nLos artículos científicos son una fuente importante de información para la comunidad científica. En ellos, los autores presentan sus resultados y conclusiones, y utilizan gráficos para ilustrar sus hallazgos. A continuación, se muestra un ejemplo de un gráfico extraído de un artículo científico:\n\n\n\n\n\nFig. 1.1: Gráfico de barras con barras de error extraído de Modesto et al. (2021)\n\n\n\n1.1.2 Periódicos\nLos periódicos son una fuente de información para el público en general. En ellos, los periodistas utilizan gráficos para ilustrar noticias y tendencias. A continuación, se muestra un ejemplo de un gráfico extraído del periódico español El País:\n\n\n\n\n\nFig. 1.2: Visualización del periódico El País\n\n\nEn la Figura 1.2 tenemos dos tipos de figuras que seguramente todos hemos visto. Dirías que la forma de representar estos datos es adecuada?\nPuede que inicialmente sea complejo de ver, pero si te fijas, aunque los dos gráficos parecen de barras con la misma estructura, verás que el superior es un gráfico de barras donde ambas barras empiezan en 0, mientras que el inferior es otro gráfico de barras donde las barras se acumulan, de forma que el final de una barra es el inicio de la siguiente. Esto trae una serie de implicaciones en la interpretación de los datos, ya que en el primer caso se pueden comparar las barras directamente, mientras que en el segundo caso, aunque se pueden comparar las barras, es más complicado ver la diferencia entre ellas. Sabrías decirme si la producción de petróleo de esquisto será mayor en 2025 o en 2040? La producción de gas de esquisto de 2040, cuánto de mayor es que la de 2010? Cinco veces mayor, siete veces mayor?\nEn este curso, aunque no podremos introducirnos en la teoría y fundamentos de la visualización de datos, intentaremos enseñaros a crear gráficos sencillos que muestran la información de forma clara y comunicativa siguiendo los principios básicos de la visualización de datos.\n\n1.1.3 Aplicaciones\nHoy en día existen muchas aplicaciones que utilizan gráficos para presentar información a los usuarios, como pueden ser aplicaciones bancarias, de salud o de deportes. El siguiente ejemplo muestra la aplicación de Huawei Health:\n\n\n\n\n\nFig. 1.3: Visualización de la aplicación Huawei Health\n\n\nAquí podemos ver un gráfico de barras donde se representan las kcal quemadas por el usuario cada día de la útlima semana. A continuación, se muestran unos indicadores del total de kcal quemadas en la última semana y la media semanal, ya que son valores que usualmente consultamos. Finalmente, se muestra un gráfico de barras apilado con el tipo de actividad que ha consumido las kcal anteriores. Además, nos permite consultar las mismas estadísticas por día, mes y año.\n\n1.1.4 Facturas\nSi revisas tus facturas, verás que muchas de ellas incluyen gráficos para ilustrar tus gastos o consumos. A continuación, se muestra un ejemplo de una factura de Naturgy:\n\n\n\n\n\nFig. 1.4: Visualización de la factura de Naturgy\n\n\nAquí podemos ver dos gráficos. Una gráfico de barras apilado y un gráfico circular. Desafortunadamente, muchos profesionales utilizan este tipo de gráficos para presentar información, pero no son los más adecuados para ello. Por ejemplo, en el gráfico circular, es difícil comparar las proporciones de los diferentes conceptos, ya que no es fácil comparar ángulos. Para tener una idea clara de lo que estamos comparando, tenemos que acudir a las etiquetas, lo que no es lo más adecuado.\n\n\n\n\n\n\nAdvertencia\n\n\n\nLos gráficos circulares son utilizados por un montón de gente, y odiados por los expertos en visualización de datos. En el siguiente ejemplo puedes ver un ejemplo de por qué no son recomendables.\n\n\n\n\n\n\n\nFig. 1.5: Comparación de gráficos circulares y de barras\n\n\n\n\nEn el gráfico anterior, se comparan los mismos datos utilizando un gráfico circular y un gráfico de barras. Cuál de los dos gráficos te parece más fácil de interpretar?\n\n\nPor otro lado, en el gráfico de barras apilado, es sencillo comparar la primera barra ya que todas tienen el mismo origen (0). Sin embargo, comparar las barras siguientes es más complicado, ya que no podemos comparar directamente las alturas de las barras. Además, al no tener un eje de referencia, no podemos saber cuánto representa cada barra.\n\n1.1.5 Otros\nEn general, la visualización de datos está presente en muchos aspectos de nuestra vida diaria, desde la televisión, las redes sociales hasta la ciencia. Desafortunadamente, en este curso no nos dará tiempo a cubrir muchos aspectos de la visualización de datos y de las buenas prácticas, si no que estará enfocado principalmente en aprender a utilizar ggplot2 para crear gráficos sencillos pero efectivos.",
    "crumbs": [
      "Visualización",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la visualización de datos</span>"
    ]
  },
  {
    "objectID": "1002_introduction.html#referencias",
    "href": "1002_introduction.html#referencias",
    "title": "\n1  Introducción a la visualización de datos\n",
    "section": "Referencias",
    "text": "Referencias\n\n\nModesto, Inês, Lieven Sterck, Vicent Arbona, Aurelio Gómez-Cadenas, Isabel Carrasquinho, Yves Van de Peer, y Célia M. Miguel. 2021. «Insights Into the Mechanisms Implicated in Pinus pinaster Resistance to Pinewood Nematode». Frontiers in Plant Science 12. https://doi.org/10.3389/fpls.2021.690857.",
    "crumbs": [
      "Visualización",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la visualización de datos</span>"
    ]
  },
  {
    "objectID": "1003_first_steps.html",
    "href": "1003_first_steps.html",
    "title": "\n2  Primeros pasos con ggplot2\n",
    "section": "",
    "text": "2.1 Objetivos\nEn esta sección, trabajaremos con los siguientes paquetes:\nCódigolibrary(dplyr)\nlibrary(ggplot2)\nlibrary(skimr)\nlibrary(readr)",
    "crumbs": [
      "Visualización",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeros pasos con ggplot2</span>"
    ]
  },
  {
    "objectID": "1003_first_steps.html#sec-vis-objectives",
    "href": "1003_first_steps.html#sec-vis-objectives",
    "title": "\n2  Primeros pasos con ggplot2\n",
    "section": "",
    "text": "Entender la gramática de gráficos y su implicación dentro de ggplot2\nEstudiar los componentes que formar un gráfico en ggplot2\nCrear gráficos sencillos\nEntender como funciona la herencia de datos y estéticas\nEstudiar la diferencia entre mapear y asignar una estética",
    "crumbs": [
      "Visualización",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeros pasos con ggplot2</span>"
    ]
  },
  {
    "objectID": "1003_first_steps.html#sec-vis-data",
    "href": "1003_first_steps.html#sec-vis-data",
    "title": "\n2  Primeros pasos con ggplot2\n",
    "section": "\n2.2 Datos de trabajo",
    "text": "2.2 Datos de trabajo\nAntes de comenzar a trabajar con ggplot2, vamos a explorar los datos con los que vamos a trabajar. En este caso, vamos a utilizar un conjunto de datos de ejemplo que contiene información sobre una serie de árboles. Para cargar los datos, utilizaremos la función read_rds() del paquete readr:\n\nCódigoinventario_tbl &lt;- read_rds(\"data/inventario_prep.rds\")\n\n\nUna vez que hemos cargado los datos, vamos a utilizar la función skim del paquete skimr para obtener un resumen de los datos:\n\nCódigoskim(inventario_tbl)\n\n\nData summary\n\n\nName\ninventario_tbl\n\n\nNumber of rows\n1540\n\n\nNumber of columns\n4\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nfactor\n2\n\n\nnumeric\n2\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: factor\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nordered\nn_unique\ntop_counts\n\n\n\nid_plots\n0\n1\nFALSE\n27\n17: 111, 11: 91, 5: 89, 14: 79\n\n\nnombre_ifn\n0\n1\nFALSE\n2\nPin: 1302, Pin: 238\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\ndbh_mm\n12\n0.99\n184.85\n50.97\n65.0\n153.75\n177.00\n207.00\n531.00\n▃▇▁▁▁\n\n\nheight_m\n1120\n0.27\n9.49\n3.27\n3.3\n7.39\n8.57\n10.47\n21.99\n▂▇▂▁▁\n\n\n\n\n\nEsta función nos proporciona información sobre las variables del conjunto de datos, incluyendo el tipo de variable, el número de observaciones, el número de valores faltantes (NA), la media, la desviación estándar, los valores mínimos y máximos, y los cuartiles.\nTenemos 2 variables numéricas que son el diámetro y la altura de los árboles, y 2 variables categóricas que son la especie (Pinus nigra o Pinus sylvestris) y un identificador de la parcela de inventario (27 parcelas distintas). Para el diámetro, tenemos un total de 12 valores ausentes (NA) que son aproximadamente un 1% de los datos. Para la altura, tenemos 1120 valores ausentes, que son aproximadamente un 73% de los datos. En este sentido, es importante tener en cuenta que los valores ausentes pueden afectar a los análisis y visualizaciones que realicemos con los datos.\n\n\n\n\n\n\nNota\n\n\n\nAunque estos datos tengan una estructura muy sencilla, nos servirán a la perfección para los objetivos de este curso. Nuestro objetivo será entender la gramática de gráficos como una base fundamental que nos permitirá transmitir el mensaje que deseemos con nuestros datos.",
    "crumbs": [
      "Visualización",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeros pasos con ggplot2</span>"
    ]
  },
  {
    "objectID": "1003_first_steps.html#sec-gog",
    "href": "1003_first_steps.html#sec-gog",
    "title": "\n2  Primeros pasos con ggplot2\n",
    "section": "\n2.3 Gramática de gráficos",
    "text": "2.3 Gramática de gráficos\nLa gramática de gráficos es un conjunto de reglas que definen cómo se pueden construir gráficos a partir de componentes básicos, y fue creada por Wilkinson (2005). La idea de crear una gramática de gráficos es que, al igual que en la gramática de un idioma, se pueden combinar diferentes elementos para crear gráficos complejos. Cuando aprendemos a hablar un idioma, aprendemos las reglas gramaticales y el vocabulario, y con estos elementos podemos crear frases y textos. De la misma forma, al aprender la gramática de gráficos, podemos crear gráficos complejos a partir de componentes básicos.\nPosteriormente se creó ggplot2 (Wickham 2010), que utiliza las reglas gramaticales de la gramática de gráficos para crear gráficos en R. ggplot2 se basa en la idea de que un gráfico se puede construir a partir de capas, y cada capa se puede añadir al gráfico para añadir información adicional.",
    "crumbs": [
      "Visualización",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeros pasos con ggplot2</span>"
    ]
  },
  {
    "objectID": "1003_first_steps.html#sec-components",
    "href": "1003_first_steps.html#sec-components",
    "title": "\n2  Primeros pasos con ggplot2\n",
    "section": "\n2.4 Componentes",
    "text": "2.4 Componentes\nLa gramática de gráficos tiene una serie de componentes diferenciados Figura 2.1 que se definen en Wickham (2010). Estos componentes son:\n\nDatos (data): conjunto de datos que utilizamos para generar el gráfico.\nGeometrías (geom): se refiere a la forma de representación de nuestros datos. Algunos ejemplos de geometrías son: puntos, líneas, histograma, diagramas de caja, etc.\nEstéticas (aes): también denominados aesthetic mappings. Se refiere a los elementos que definen la estética de las geometrías. Si ponemos el ejemplo de un gráfico de puntos (scatter plot), las estéticas pueden ser: su forma (punto, rectángulo, triángulo…), su tamaño, color, transparencia …\nTransformaciones estadísticas (stat):se refiere al estadístico utilizado para resumir nuestros datos. Por ejemplo, para crear un histograma resumimos nuestros datos en intervalos (bins) y contamos el número de observaciones que existen dentro de este intervalo. Este componente es más avanzado que el resto, por lo que trabajaremos solamente con los valores que vienen por defecto.\nEscalas (scale): transforman los valores de los datos en estéticas. Nos permiten controlar los colores, tamaños, formas, etc. También nos permiten controlar aspectos de las leyendas y ejes.\n\n\n\n\n\n\n\nImportante\n\n\n\nExiste una escala por cada estética utilizada.\n\n\n\nFacetas (facets): consiste en generar subgráficos según un atributo. Por ejemplo, utilizando nuestros datos de inventario, podemos generar un gráfico de puntos donde representemos la relación diámetro-altura para todos los datos, o bien podemos generar facetas que generen un gráfico por cada una de las especies (es decir, un scatter plot para P. nigra y otro distinto para P. sylvestris).\nCoordenadas (coord): sistema de coordenadas utilizado para mapear los datos. Por defecto y normalmente, utilizaremos el sistema de coordenadas cartesiano. Otros sistemas disponibles son el sistema de coordenadas polares (que nos permiten crear los increíbles gráficos circulares), o también sistemas de referencia de coordenadas para generar mapas (sí, con ggplot2 podemos generar mapas🗺️).\nTema (theme): nos permite controlar todos los aspectos relacionados con la apariencia del gráfico, como puede ser la fuente de texto, tamaño de fuente, posición de elementos como la leyenda, colores de relleno, etc.\n\n\n\n\n\n\nFig. 2.1: Componentes principales de la gramática de gráficos\n\n\nFinalmente, podemos definir una capa como la combinación de datos, estéticas, geometrías y transformaciones estadísticas (Wickham, Navarro, y Pedersen 2021), y en la mayoría de las ocasiones, estos cuatro componentes se especificarán dentro de una función que comienza por geom_*, aunque los datos y las estéticas también se pueden especificar dentro de la función ggplot(). No os preocupéis, pronto veremos las diferencias entre estas opciones.\n\n\n\n\n\n\nImportante\n\n\n\nUn mismo gráfico puede contener más de una capa y estas capas pueden (o no) compartir los mismo datos:\n\nCapa 1: utiliza los datos de inventario, como estéticas utiliza las variables DBH_mm y height_m, la geometría de punto y como transformación estadística utiliza identity. Esta transformación es utilizada por muchas geometrías y significa que va a utilizar los valores tal cual aparecen en la tabla de datos, sin realizar ninguna transformación. En términos matemáticos significa que \\(f(x)= x\\).\nCapa 2: utiliza los datos de inventario, como estéticas utiliza las variables DBH_mm y height_m, la geometría de línea y como transformación estadística utiliza smooth. Esta transformación utiliza un método de suavizado (por defecto una Regresión Local (LOESS)) donde se genera una línea que aproxima la tendencia de los datos.\n\n\n\n\n\n\n\n\n\n\n\nEl tipo de gráfico viene definido por dos elementos: el tipo de geometría y la transformación estadística. Por poner un ejemplo relacionado con el anterior:\n\nGráfico de líneas: se define por una geometría de línea y una transformación estadística identity (geom_line(stat = \"identity\")).\nGráfico suavizado: utiliza la geometría de línea y una transformación estadística smooth (geom_line(stat = \"smooth\")).\n\nNo obstante, los gráficos comunes como el gráfico suavizado vienen incluidos en ggplot2 a través de una función que utiliza la transformación estadística adecuada por defecto, y solamente nos hará falta llamar a la función adecuada sin utilizar el argumento stat:\n\n\nFunción\nT.E. por defecto\n\n\n\ngeom_line()\nidentity\n\n\ngeom_smooth()\nsmooth",
    "crumbs": [
      "Visualización",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeros pasos con ggplot2</span>"
    ]
  },
  {
    "objectID": "1003_first_steps.html#sec-first-example",
    "href": "1003_first_steps.html#sec-first-example",
    "title": "\n2  Primeros pasos con ggplot2\n",
    "section": "\n2.5 Ejemplo rápido",
    "text": "2.5 Ejemplo rápido\nPara digerir los conceptos anteriores, vamos a ver un ejemplo rápido. Para este ejemplo, vamos a eliminar los valores ausentes, ya que el objetivo es solamente entender los conceptos anteriores y no generar un gráfico para publicar.\n\nCódigoinventario_completo_tbl &lt;- na.omit(inventario_tbl)\nprint(inventario_completo_tbl)\n\n# A tibble: 418 × 4\n   id_plots dbh_mm height_m nombre_ifn      \n   &lt;fct&gt;     &lt;int&gt;    &lt;dbl&gt; &lt;fct&gt;           \n 1 0           296     9.26 Pinus sylvestris\n 2 0           303    10.1  Pinus sylvestris\n 3 0           105     5.48 Pinus sylvestris\n 4 0           138     7.07 Pinus nigra     \n 5 0           153     7.54 Pinus sylvestris\n 6 0           233     9.60 Pinus sylvestris\n 7 0           140     7.01 Pinus sylvestris\n 8 0           200     7.36 Pinus sylvestris\n 9 0           210    10.1  Pinus sylvestris\n10 0           142     6.25 Pinus sylvestris\n# ℹ 408 more rows\n\n\nDe este modo nos quedamos con 418 observaciones.\n\n\nLíneas\nSuavizado 1\nSuavizado 2\n\n\n\n\nCódigoinventario_completo_tbl |&gt; \n    ggplot(\n        aes(x = dbh_mm, y = height_m)\n    ) +\n    geom_line()\n\n\n\n\n\n\nFig. 2.2: Ejemplo básico de gráfico de líneas\n\n\n\n\n\n\n\nCódigoinventario_completo_tbl |&gt; \n    ggplot(\n        aes(x = dbh_mm, y = height_m)\n    ) +\n    geom_line(\n        stat = \"smooth\"\n    )\n\n\n\n\n\n\nFig. 2.3: Ejemplo básico de línea suavizada con geom_line()\n\n\n\n\n\n\n\nCódigoinventario_completo_tbl |&gt; \n    ggplot(\n        aes(x = dbh_mm, y = height_m)\n    ) +\n    geom_smooth()\n\n\n\n\n\n\nFig. 2.4: Ejemplo básico de línea suavizada con geom_smooth()\n\n\n\n\n\n\n\nCompara las tres gráficas. En Figura 2.2 no utilizamos el argumento stat ya que el que viene por defecto es identity. Del mismo modo, en Figura 2.4 tampoco es necesario utilizar el argumento ya que stat = \"smooth\" viene por defecto.\n\n\n\n\n\n\nNota\n\n\n\nEn este curso no vamos a trabajar con transformaciones estadísticas en mayor profundidad. Esta sección solamente quiere remarcar que detrás de cada geometría existe una transformación estadística que viene dada por defecto.\n\n\nTambién te habrás dado cuenta de que no hemos utilizado los componentes: facetas, escalas, coordenadas ni tema. Esto se debe a que estos componentes siempre, en todos los gráficos tienen un valor por defecto. Pero todo a su tiempo. Vamos a empezar desengranando el código anterior. Para tener una idea de los argumentos que estamos utilizando vamos a comparar los siguientes gráficos derivados de Figura 2.4:\n\n\nMétodo 1\nMétodo 2\nMétodo 3\nMétodo 4\n\n\n\n\nCódigoggplot(\n    data    = inventario_completo_tbl,\n    mapping = aes(x = dbh_mm, y = height_m)\n) +\n    geom_smooth()\n\n\n\n\n\n\n\n\n\n\nCódigoggplot(inventario_completo_tbl, aes(x = dbh_mm, y = height_m)) +\n    geom_smooth()\n\n\n\n\n\n\n\n\n\n\nCódigoggplot(\n    inventario_completo_tbl, \n    aes(x = dbh_mm, y = height_m)\n) +\n    geom_smooth()\n\n\n\n\n\n\n\n\n\n\nCódigoinventario_completo_tbl |&gt; \n    ggplot(\n        aes(x = dbh_mm, y = height_m)\n    ) +\n    geom_smooth()\n\n\n\n\n\n\n\n\n\n\nComo veis, el resultado es exactamente el mismo. Normalmente utilizaremos el pipe operator (|&gt; o %&gt;%) como hacemos en el método 4 para inyectar los datos en el primer argumento de la función ggplot() que es data. El argumento mapping también se sabe perfectamente que es el segundo argumento de la función, por lo que no es necesario escribir mapping = ... si no directamente aes(...). En resumen, cualquier método de escritura de código de los anteriores se adecua en mayor o menor medida a los principios de diseño ordenado (Wickham 2014). No obstante, los métodos más adecuados serán los métodos 3 y 4 ya que nos ayudarán a que nuestro código sea más legible dado que la indentación nos ayuda a ver a qué función pertenece cada argumento y hará que nuestro código sea mucho más fácil de leer y mantener. Finalmente, para añadir componentes a nuestro gráfico utilizamos el operador matemático +.\n\n\n\n\n\n\nAdvertencia\n\n\n\nDesgraciadamente, mucha gente utiliza el método 2 para escribir código. Aunque en el ejemplo anterior no es algo grave, es una mala costumbre para muchos otros casos. Entiendes el siguiente código?\n\nCódigofilter(select(filter(inventario_completo_tbl, dbh_mm &gt;= 300), dbh_mm:nombre_ifn), nombre_ifn == \"Pinus sylvestris\")\n\n# A tibble: 29 × 3\n   dbh_mm height_m nombre_ifn      \n    &lt;int&gt;    &lt;dbl&gt; &lt;fct&gt;           \n 1    303     10.1 Pinus sylvestris\n 2    309     10.3 Pinus sylvestris\n 3    494     14.3 Pinus sylvestris\n 4    335     18.9 Pinus sylvestris\n 5    300     12.3 Pinus sylvestris\n 6    326     15.1 Pinus sylvestris\n 7    325     14.7 Pinus sylvestris\n 8    343     14.9 Pinus sylvestris\n 9    329     11.6 Pinus sylvestris\n10    328     18.9 Pinus sylvestris\n# ℹ 19 more rows\n\n\nY si lo escribo de este modo?\n\nCódigofilter(\n    select(\n        filter(\n            inventario_completo_tbl, dbh_mm &gt;= 300\n        ), \n        dbh_mm:nombre_ifn), \n    nombre_ifn == \"Pinus sylvestris\"\n)\n\n# A tibble: 29 × 3\n   dbh_mm height_m nombre_ifn      \n    &lt;int&gt;    &lt;dbl&gt; &lt;fct&gt;           \n 1    303     10.1 Pinus sylvestris\n 2    309     10.3 Pinus sylvestris\n 3    494     14.3 Pinus sylvestris\n 4    335     18.9 Pinus sylvestris\n 5    300     12.3 Pinus sylvestris\n 6    326     15.1 Pinus sylvestris\n 7    325     14.7 Pinus sylvestris\n 8    343     14.9 Pinus sylvestris\n 9    329     11.6 Pinus sylvestris\n10    328     18.9 Pinus sylvestris\n# ℹ 19 more rows\n\n\nY de este?\n\nCódigoinventario_completo_tbl |&gt; \n    filter(dbh_mm &gt;= 300) |&gt; \n    select(dbh_mm:nombre_ifn) |&gt; \n    filter(nombre_ifn == \"Pinus sylvestris\")\n\n# A tibble: 29 × 3\n   dbh_mm height_m nombre_ifn      \n    &lt;int&gt;    &lt;dbl&gt; &lt;fct&gt;           \n 1    303     10.1 Pinus sylvestris\n 2    309     10.3 Pinus sylvestris\n 3    494     14.3 Pinus sylvestris\n 4    335     18.9 Pinus sylvestris\n 5    300     12.3 Pinus sylvestris\n 6    326     15.1 Pinus sylvestris\n 7    325     14.7 Pinus sylvestris\n 8    343     14.9 Pinus sylvestris\n 9    329     11.6 Pinus sylvestris\n10    328     18.9 Pinus sylvestris\n# ℹ 19 more rows\n\n\nComo ves, tres formas de escribir el mismo código aumentando la legibilidad del mismo. Estos principios se utilizarán a lo largo de este curso. Una lectura muy recomendable es The tidyverse style guide.",
    "crumbs": [
      "Visualización",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeros pasos con ggplot2</span>"
    ]
  },
  {
    "objectID": "1003_first_steps.html#sec-inheritance-aes",
    "href": "1003_first_steps.html#sec-inheritance-aes",
    "title": "\n2  Primeros pasos con ggplot2\n",
    "section": "\n2.6 Herencia de estéticas",
    "text": "2.6 Herencia de estéticas\nVamos a continuar con el ejemplo de la línea suavizada. Vamos a añadir otra capa donde se muestre la distribución de las observaciones con una geometría de punto:\n\nCódigoinventario_completo_tbl |&gt; \n    ggplot(\n        aes(x = dbh_mm, y = height_m)\n    ) +\n    geom_point() +\n    geom_smooth()\n\n\n\n\n\n\n\nEn este ejemplo estamos viendo una propiedad MUY IMPORTANTE en relación a la generación de gráficos con ggplot2. Dentro de la función ggplot() introducimos las estéticas y los datos. En siguiente lugar, las geometrías heredan estos elementos. Es decir, este gráfico podría ser algo más verboso del siguiente modo:\n\nCódigoggplot() +\n    geom_point(\n        data = inventario_completo_tbl,\n        aes(x = dbh_mm, y = height_m)\n    ) +\n    geom_smooth(\n        data = inventario_completo_tbl,\n        aes(x = dbh_mm, y = height_m)\n    ) \n\n\n\n\n\n\n\nEn este caso, estamos especificando los datos y las estéticas en cada una de las geometrías. Aunque esto es posible, no es recomendable ya que aumenta la longitud del código y puede llevar a errores si no se especifican correctamente los datos y las estéticas en cada una de las geometrías. No obstante, en muchos casos es necesario especificar los datos y las estéticas en cada una de las geometrías, ya que pueden utilizar estéticas diferentes o incluso datos diferentes. Vamos a ver un caso sencillo donde queremos representar la relación entre el diámetro y la altura de los árboles, pero queremos que los puntos de una especie sean de un color diferente a los de la otra especie. Vamos a ver una serie de ejemplos:\n\n\nColor - Todos\nColor - Puntos\nColor - Smooth\n\n\n\nEn este caso introducimos la estética color dentro de la función de ggplot(). En este caso todas las geometrías heredan las estéticas:\n\nCódigoinventario_completo_tbl |&gt; \n    ggplot(\n        aes(x = dbh_mm, y = height_m, color = nombre_ifn)\n    ) +\n    geom_point() +\n    geom_smooth() \n\n\n\n\n\n\nFig. 2.5: Ejemplo de scatter plot y línea de tendencia con estética de color para ambas geometrías\n\n\n\n\n\n\nEn este otro caso, introducimos la estética color solamente dentro de la función geom_point(), por lo que solamente los puntos utilizan esta estética:\n\nCódigoinventario_completo_tbl |&gt; \n    ggplot(\n        aes(x = dbh_mm, y = height_m)\n    ) +\n    geom_point(aes(color = nombre_ifn)) +\n    geom_smooth()\n\n\n\n\n\n\nFig. 2.6: Ejemplo de scatter plot y línea de tendencia con estética de color para la geometría de punto\n\n\n\n\n\n\nEn este último caso, añadimos la estética color a función geom_smooth(), por lo que solamente se colorean las líneas de tendencia:\n\nCódigoinventario_completo_tbl |&gt; \n    ggplot(\n        aes(x = dbh_mm, y = height_m)\n    ) +\n    geom_point() +\n    geom_smooth(aes(color = nombre_ifn))\n\n\n\n\n\n\nFig. 2.7: Ejemplo de scatter plot y línea de tendencia con estética de color para la geometría de la línea de tendencia\n\n\n\n\n\n\n\nTambién puedes ver que en los ejemplos anteriores, la geometría de punto la escribimos antes que la línea de tendencia. De este modo se dibujan en el gráfico, primero los puntos, y en siguiente lugar se dibuja la línea de tendencia sobre los puntos.",
    "crumbs": [
      "Visualización",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeros pasos con ggplot2</span>"
    ]
  },
  {
    "objectID": "1003_first_steps.html#sec-map-assign-aes",
    "href": "1003_first_steps.html#sec-map-assign-aes",
    "title": "\n2  Primeros pasos con ggplot2\n",
    "section": "\n2.7 Mapear y asignar estéticas",
    "text": "2.7 Mapear y asignar estéticas\nPara finalizar este capítulo, vamos a ver dos conceptos que al principio pueden parecer un poco confusos, pero que veréis que tienen todo el sentido del mundo dentro de la gramática de gráficos. Vamos a comenzar viendo estas dos frases que inicialmente no tendrán mucho sentido, pero que entenderemos al final de esta sección:\n\nMapeamos estéticas a variables\nAsignamos estéticas a valores constantes\n\nVamos a seguir trabajando con la geometría de puntos, ya que es una de las más sencillas para aprender la teoría. Si buscáis en la documentación oficial de las funciones geom_*, encontraréis una sección de estéticas como la que se muestra en la Figura 2.8:\n\n\n\n\n\nFig. 2.8: Estétitcas de la geometría de punto (geom_point)\n\n\n\n\n\n\n\n\nImportante\n\n\n\nTodas las geometrías tienen una serie de estéticas obligatorias y otras opcionales. Para la geometría de punto las obligatorias son x e y\n\n\nTODAS estas estéticas se pueden mapear a variables, es decir, todas pueden ir dentro de la función aes(x, y, alpha, color, fill ...). Siempre que vayan dentro de la función aes(), estaremos mapeando la estética a una variable, y por lo tanto, el valor de la estética debe ser una variable de nuestros datos como en el siguiente exagerado ejemplo:\n\nCódigoinventario_completo_tbl |&gt; \n    ggplot(\n        aes(\n            x     = dbh_mm,\n            y     = height_m,\n            color = nombre_ifn,\n            shape = nombre_ifn,\n            size  = height_m\n        )\n    ) +\n    geom_point()\n\n\n\n\n\n\n\nSin embargo, algunas de las estéticas también se pueden asignar a valores constantes. Es decir, en lugar de generar un color de punto por cada especie, podemos elegir que todos los puntos sean de color verde oscuro. O que la forma de todos los puntos sea triangular. En este caso hablamos de asignar constantes, y las estéticas se escriben dentro de la función de geom_* y fuera de aes():\n\nCódigoinventario_completo_tbl |&gt; \n    ggplot(\n        aes(x = dbh_mm, y = height_m)\n    ) +\n    geom_point(\n        color = \"darkgreen\",\n        shape = \"triangle\",\n        size  = 3\n    )\n\n\n\n\n\n\n\nEn este sentido, algo que NO podemos hacer y que suele ser un fallo común al empezar con ggplot2 es lo siguiente:\n\nCódigoinventario_completo_tbl |&gt; \n    ggplot(\n        aes(x = dbh_mm, y = height_m)\n    ) +\n    geom_point(\n        color = nombre_ifn\n    )\n\n\nNos dará el error “Error : objeto ‘nombre_ifn’ no encontrado”. Como color está fuera de aes(), la función está buscando si en el entorno existe el objeto nombre_ifn. Para entender este concepto, vamos a ver el siguiente código:\n\nCódigo## Asignar un color a un objeto\nnombre_ifn &lt;- \"#456435\"\n## Gráfico\ninventario_completo_tbl |&gt; \n    ggplot(\n        aes(x = dbh_mm, y = height_m)\n    ) +\n    geom_point(\n        color = nombre_ifn\n    )\n\n\n\n\n\n\n\nCuando una estética se encuentra fuera de aes(), no busca nombre_ifn dentro de las columnas de los datos, si no que lo busca en el Global Environment. Finalmente, tampoco podemos introducir constantes dentro de aes():\n\nCódigoinventario_completo_tbl |&gt; \n    ggplot(\n        aes(x = dbh_mm, y = height_m, color = \"blue\")\n    ) +\n    geom_point()\n\n\n\n\n\n\n\nEsto no funciona porque lo que hace es crear una variable constante cuyos valores son “blue”. Es decir, esto es equivalente a:\n\nCódigoinventario_completo_tbl |&gt; \n    mutate(\n        colour = \"blue\"\n    ) |&gt; \n    ggplot(\n        aes(x = dbh_mm, y = height_m, color = colour)\n    ) +\n    geom_point()\n\n\n\n\n\n\n\nEs decir, no tiene nada de sentido. Para finalizar, vamos a resumir esta sección de nuevo en las frases que veíamos al inicio:\n\nMapeamos estéticas a variables\nAsignamos estéticas a valores constantes",
    "crumbs": [
      "Visualización",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeros pasos con ggplot2</span>"
    ]
  },
  {
    "objectID": "1003_first_steps.html#referencias",
    "href": "1003_first_steps.html#referencias",
    "title": "\n2  Primeros pasos con ggplot2\n",
    "section": "Referencias",
    "text": "Referencias\n\n\nWickham, Hadley. 2010. «A layered grammar of graphics». Journal of Computational and Graphical Statistics 19 (1): 3-28. https://doi.org/10.1198/jcgs.2009.07098.\n\n\n———. 2014. Tidy Data. Springer International Publishing. https://doi.org/10.1007/978-3-319-24277-4.\n\n\nWickham, Hadley, Danielle Navarro, y Thomas Lin Pedersen. 2021. ggplot2: Elegant Graphics for Data Analysis. Springer International Publishing. https://doi.org/10.1007/978-3-319-24277-4.\n\n\nWilkinson, Leland. 2005. The Grammar of Graphics. https://doi.org/10.1007/0-387-28695-0.",
    "crumbs": [
      "Visualización",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeros pasos con ggplot2</span>"
    ]
  },
  {
    "objectID": "1004_components.html",
    "href": "1004_components.html",
    "title": "\n3  Componentes\n",
    "section": "",
    "text": "3.1 Capas\nEn primer lugar, vamos a generar un gráfico utilizando los datos del inventario forestal visto en el capítulo anterior, donde mostraremos la relación entre la altura y el diámetro de los árboles por especie.\nCódigo## Crear gráfico\nbase_gg &lt;- inventario_completo_tbl |&gt; \n    ggplot(\n      aes(x = dbh_mm, y = height_m, color = nombre_ifn)\n    ) +\n    geom_point()\n## Imprimir gráfico\nbase_gg\n\n\n\n\n\n\nFig. 3.1: Gráfico con capas",
    "crumbs": [
      "Visualización",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Componentes</span>"
    ]
  },
  {
    "objectID": "1004_components.html#facetas",
    "href": "1004_components.html#facetas",
    "title": "\n3  Componentes\n",
    "section": "\n3.2 Facetas",
    "text": "3.2 Facetas\nLas facetas son una forma de dividir un gráfico en subgráficos, de acuerdo a una variable categórica. Por defecto, ggplot2 utiliza la función facet_null() que indica que no se desea dividir el gráfico. Para comprobar que esto es cierto, vamos a añadir esta función al gráfico anterior.\n\n\n\n\n\n\nTip\n\n\n\nUna característica de ggplot2 es que podemos guardar el gráfico en un objeto y añadir capas adicionales posteriormente.\n\n\n\nCódigo## Añadir facetas\nfacets_gg &lt;- base_gg + \n    facet_null()\n## Imprimir gráfico\nfacets_gg\n\n\n\n\n\n\nFig. 3.2: Gráfico sin facetas\n\n\n\n\nVemos que el resultado de la Figura 3.2 es exactamente igual al de la Figura 3.1. En el capítulo  veremos otras opciones de facetas.",
    "crumbs": [
      "Visualización",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Componentes</span>"
    ]
  },
  {
    "objectID": "1004_components.html#escalas",
    "href": "1004_components.html#escalas",
    "title": "\n3  Componentes\n",
    "section": "\n3.3 Escalas",
    "text": "3.3 Escalas\nLas escalas se encargar de mapear los valores de los datos a los valores estéticos (Wickham 2010). En nuestro gráfico, hemos utilizado un total de tres estéticas:\n\n\nx: diámetro del árbol en milímetros\n\ny: altura del árbol en metros\n\ncolor: especie del árbol\n\nPor ello, por defecto se genera una escala para cada una de estas estéticas. Vamos a ver las que se generan por defecto:\n\nCódigo##  Añadir escalas\nscales_gg &lt;- base_gg + \n    scale_x_continuous() +\n    scale_y_continuous() +\n    scale_color_discrete()\n## Imprimir gráfico\nscales_gg\n\n\n\n\n\n\nFig. 3.3: Escalas por defecto\n\n\n\n\nVemos varias cosas interesantes en el código que hemos añadido:\n\nLas funciones de escalas empiezan por scale_*\n\nEn siguiente lugar, se añade el nombre de la estética que se quiere modificar\nFinalmente, se añaden los argumentos necesarios para modificar la escala\n\nEl tercer punto es importante. Si tenemos una variable numérica, su escala será scale_*_continuous(), mientras que si es categórica, será scale_*_discrete().\nVeremos los detalles de las escalas en el capítulo .",
    "crumbs": [
      "Visualización",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Componentes</span>"
    ]
  },
  {
    "objectID": "1004_components.html#coordenadas",
    "href": "1004_components.html#coordenadas",
    "title": "\n3  Componentes\n",
    "section": "\n3.4 Coordenadas",
    "text": "3.4 Coordenadas\nLas coordenadas definen cómo se representan los datos en el gráfico. Por defecto, ggplot2 utiliza un sistema de coordenadas cartesianas. Vamos a ver cómo se ve nuestro gráfico con las coordenadas por defecto.\n\nCódigo## Añadir coordenadas\ncoord_gg &lt;- base_gg + \n    coord_cartesian()\n## Imprimir gráfico\ncoord_gg\n\n\n\n\n\n\nFig. 3.4: Coordenadas por defecto\n\n\n\n\nDe nuevo, vemos que no se ha modificado el gráfico. Las funciones de coordenadas empiezan por coord_*, y en el capítulo  veremos otras opciones de coordenadas.",
    "crumbs": [
      "Visualización",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Componentes</span>"
    ]
  },
  {
    "objectID": "1004_components.html#temas",
    "href": "1004_components.html#temas",
    "title": "\n3  Componentes\n",
    "section": "\n3.5 Temas",
    "text": "3.5 Temas\nLos temas definen el aspecto visual del gráfico. Por defecto, ggplot2 utiliza el tema theme_gray():\n\nCódigo## Añadir tema\ntheme_gg &lt;- base_gg + \n    theme_gray() +\n    theme()\n## Imprimir gráfico\ntheme_gg\n\n\n\n\n\n\nFig. 3.5: Tema por defecto\n\n\n\n\nEn el código anterior vemos dos funciones:\n\ntheme_*: se utilizan para aplicar un tema predeterminado que trae una serie de valores de los temas por defecto.\ntheme(): se utiliza para personalizar propiedades de forma unitaria.\n\nDe nuevo, veremos los detalles de los temas en el capítulo .",
    "crumbs": [
      "Visualización",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Componentes</span>"
    ]
  },
  {
    "objectID": "1004_components.html#resumen",
    "href": "1004_components.html#resumen",
    "title": "\n3  Componentes\n",
    "section": "\n3.6 Resumen",
    "text": "3.6 Resumen\nEn este capítulo hemos visto los componentes de un gráfico en ggplot2 que vienen por defecto. Vamos a unir todo lo que vimos en un bloque de código:\n\nCódigoinventario_completo_tbl |&gt; \n    ## Añadir capas\n    ggplot(\n      aes(x = dbh_mm, y = height_m, color = nombre_ifn)\n    ) +\n    geom_point() +\n    ## Añadir facetas\n    facet_null() +\n    ## Añadir escalas\n    scale_x_continuous() +\n    scale_y_continuous() +\n    scale_color_discrete() +\n    ## Añadir coordenadas\n    coord_cartesian() +\n    ## Añadir tema\n    theme_gray() +\n    theme()\n\n\n\n\n\n\nFig. 3.6: Gráfico con todos los componentes",
    "crumbs": [
      "Visualización",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Componentes</span>"
    ]
  },
  {
    "objectID": "1004_components.html#referencias",
    "href": "1004_components.html#referencias",
    "title": "\n3  Componentes\n",
    "section": "Referencias",
    "text": "Referencias\n\n\nWickham, Hadley. 2010. «A layered grammar of graphics». Journal of Computational and Graphical Statistics 19 (1): 3-28. https://doi.org/10.1198/jcgs.2009.07098.",
    "crumbs": [
      "Visualización",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Componentes</span>"
    ]
  },
  {
    "objectID": "1102_distribution.html",
    "href": "1102_distribution.html",
    "title": "4  Gráficos de distribución",
    "section": "",
    "text": "4.1 Objetivos\nAl final de este capítulo, serás capaz de:",
    "crumbs": [
      "Tipos de visualización",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Gráficos de distribución</span>"
    ]
  },
  {
    "objectID": "1102_distribution.html#objetivos",
    "href": "1102_distribution.html#objetivos",
    "title": "4  Gráficos de distribución",
    "section": "",
    "text": "Utilizar etiquetas y temas prediseñados en ggplot2\nCrear histogramas en ggplot2\nCrear gráficos de densidad en ggplot2\nCrear gráficos de cajas en ggplot2\nCrear gráficos de violín en ggplot2\nAñadir líneas a los gráficos\nAñadir puntos con resúmenes estadísticos a los gráficos",
    "crumbs": [
      "Tipos de visualización",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Gráficos de distribución</span>"
    ]
  },
  {
    "objectID": "1102_distribution.html#histogramas",
    "href": "1102_distribution.html#histogramas",
    "title": "4  Gráficos de distribución",
    "section": "\n4.2 Histogramas",
    "text": "4.2 Histogramas\nLos histogramas son una forma de visualizar la distribución de una variable numérica. En un histograma, los valores de la variable se agrupan en intervalos y se muestra la frecuencia de los valores en cada intervalo. Los histogramas son útiles para identificar la forma de la distribución de los datos, la presencia de valores atípicos y la presencia de múltiples modas.\nPara crear un histograma en ggplot2, utilizamos la función geom_histogram(). Tiene dos argumentos de gran importancia:\n\nbins: número de intervalos en los que se agruparán los datos. Si no se especifica, ggplot2 utilizará 30 intervalos.\nbinwidth: ancho de los intervalos. Si se especifica, ggplot2 calculará el número de intervalos automáticamente.\n\n\n\n\n\n\n\nNota\n\n\n\nEstos dos argumentos son mutuamente excluyentes. Si se especifica bins, ggplot2 ignorará binwidth.\n\n\nVamos a ver la diferencia entre estos dos argumentos viendo la distribución de la longitud de los pétalos de las flores del dataset iris:\n\n\nNúmero de intervalos\nAncho del intervalo\n\n\n\nAl especificar el número de intervalos lo que hacemos es básicamente indicar el número de barras que queremos generar:\n#| standalone: true\n#| viewerHeight: 600\n\n## Load packages\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(glue)\nlibrary(shiny)\n\n## UI\nui &lt;- page_sidebar(\n    sidebar = sidebar(\n        open = \"open\",\n        width = 200,\n        sliderInput(\"bins\", \"Número de intervalos\", min = 1, max = 30, value = 15),\n    ),\n    verbatimTextOutput(\"code\") |&gt; card(),\n    plotOutput(\"plot\", width = 500) |&gt; card()\n)\n\n## Server\nserver &lt;- function(input, output, session) {\n    \n    output$code &lt;- renderPrint({\n        glue(\n            'ggplot(iris, aes(x = Petal.Length)) +\n                    geom_histogram(bins = {input$bins}, fill = \"#0073C2FF\", color = \"white\") +\n                    labs(\n                        title = \"Distribución de longitud del pétalo\", \n                        x = \"Longitud (mm)\", \n                        y = \"Frecuencia\"\n                    )'\n            )\n    })\n\n    ## Plot\n    output$plot &lt;- renderPlot({\n        ggplot(iris, aes(x = Petal.Length)) +\n            geom_histogram(bins = input$bins, fill = \"#0073C2FF\", color = \"white\") +\n            labs(\n                title = \"Distribución de longitud del pétalo\", \n                x = \"Longitud (cm)\", \n                y = \"Frecuencia\"\n            ) +\n            theme_gray(base_size = 8)\n    }, res = 96)\n}\n\n## Run app\nshinyApp(ui = ui, server = server)\n\n\nCuando seleccionamos el ancho del intervalo (binwidth), estamos seleccionando el tamaño del intervalo en las unidades de la variable que estamos evaluando. Por ejemplo, si seleccionamos un ancho de banda de 0.3 para la longitud del pétalo, estamos indicando que cada barra agrupará observaciones de 3 en 3 milímetros. De 0-0.3 tendremos el primer intervalo, de 0.3-0.6 el segundo, y así sucesivamente.\n#| standalone: true\n#| viewerHeight: 600\n\n## Load packages\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(glue)\nlibrary(shiny)\n\n## UI\nui &lt;- page_sidebar(\n    sidebar = sidebar(\n        open = \"open\",\n        width = 200,\n        sliderInput(\"bins\", \"Ancho del intervalo\", min = 0.1, max = 2, value = .2, step = .1),\n    ),\n    verbatimTextOutput(\"code\") |&gt; card(),\n    plotOutput(\"plot\", width = 500) |&gt; card()\n)\n\n## Server\nserver &lt;- function(input, output, session) {\n    \n    output$code &lt;- renderPrint({\n        glue(\n            '\n            ggplot(iris, aes(x = Petal.Length)) +\n                    geom_histogram(binwidth = {input$bins}, fill = \"#0073C2FF\", color = \"white\") +\n                    labs(\n                        title = \"Distribución de longitud del pétalo\", \n                        x = \"Longitud (mm)\", \n                        y = \"Frecuencia\"\n                    )'\n            )\n    })\n\n    ## Plot\n    output$plot &lt;- renderPlot({\n        ggplot(iris, aes(x = Petal.Length)) +\n            geom_histogram(binwidth = input$bins, fill = \"#0073C2FF\", color = \"white\") +\n            labs(\n                title = \"Distribución de longitud del pétalo\", \n                x     = \"Longitud (mm)\", \n                y     = \"Frecuencia\"\n            ) +\n            theme_gray(base_size = 8)\n    }, res = 96)\n}\n\n## Run app\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nLos códigos hexadecimales son una forma de representar colores en HTML y CSS. En R, podemos utilizarlos para cambiar el color de los gráficos. En este caso, el color #0073C2FF representa un azul claro. Puedes utilizar generadores de colores online como este para elegir un color.\n\n\nUn histograma es básicamente esto. Para el color de relleno utilizamos el argumento fill y para el color del contorno utilizamos el argumento color, y este patrón seguirá siendo el mismo para los otros tipos de gráficos de ggplot2.\nTambién te habrás dado cuenta que hemos añadido una función nueva que es labs(). Esta función nos permite añadir etiquetas al gráfico como:\n\ntitle: título del gráfico.\nsubtitle: subtitulo del gráfico.\nx: título del eje x.\ny: título del eje y.\ncaption: pie de figura.\n\nSi bien es cierto que los histogramas son una forma de visualizar la distribución de una sola variable, también podemos crear histogramas para comparar la distribución de una variable numérica entre diferentes grupos. Esto puede ser muy conveniente, ya que si nos fijamos en las figuras anteriores, podemos ver que si indicamos el número de intervalos adecuado sigue una distribución bimodal.\nVamos a ver qué pasa si comparamos la distribución de la longitud de los pétalos de las flores del dataset iris entre las diferentes especies de flores. Para ello, utilizamos el argumento fill en la función aes() para indicar la variable categórica que queremos comparar:\n\nCódigoggplot(iris, aes(x = Petal.Length, fill = Species)) +\n    geom_histogram(bins = 30, color = \"white\") +\n    labs(\n        title    = \"Distribución de longitud del pétalo por especie\", \n        subtitle = \"La especie I. setosa tiene una longitud de pétalo menor que I. versicolor e I. virginica\",\n        x        = \"Longitud (mm)\", \n        y        = \"Frecuencia\",\n        caption  = \"Autor: Adrián Cidre\"\n    ) +\n    theme_minimal()\n\n\n\n\n\n\nFig. 4.1: Distribución de longitud del pétalo por especie\n\n\n\n\nAhá 🤔! Gracias a utilizar una estética más podemos ver que la distribución no es bimodal, si no que son distribuciones de especies de flores distintas. En esencia, añadir una estética más puede ser visto como añadir una dimensión más al gráfico.\n\n\n\n\n\n\nNota\n\n\n\nA partir de ahora vamos a ir añadiendo nuevas funciones y argumentos a nuestros gráficos. No te preocupes si no entiendes todo a la primera, poco a poco iremos viendo cómo se utilizan y para qué sirven. En este caso hemos añadido theme_minimal() que nos permite cambiar el tema base del gráfico. Existen una serie de temas predefinidos que empiezan por theme_*().",
    "crumbs": [
      "Tipos de visualización",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Gráficos de distribución</span>"
    ]
  },
  {
    "objectID": "1102_distribution.html#gráficos-de-densidad",
    "href": "1102_distribution.html#gráficos-de-densidad",
    "title": "4  Gráficos de distribución",
    "section": "\n4.3 Gráficos de densidad",
    "text": "4.3 Gráficos de densidad\nLos gráficos de densidad son una forma de visualizar la distribución de una variable numérica. A diferencia de los histogramas, los gráficos de densidad no agrupan los datos en intervalos, sino que muestran la estimación de densidad kernel de los datos. Los gráficos de densidad son útiles para identificar la forma de la distribución de los datos, ya que son una versión suavizada de los histogramas.\nPara crear un gráfico de densidad en ggplot2, utilizamos la función geom_density(). Básicamente, se va a generar una línea que nos va a indicar la densidad de probabilidad de los datos. Como es una línea, tiene una serie de estéticas que podemos modificar a continuación:\n#| standalone: true\n#| viewerHeight: 600\n\n## Load packages\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(glue)\nlibrary(shiny)\n\n## UI\nui &lt;- page_sidebar(\n    sidebar = sidebar(\n        open  = \"open\",\n        width = 200,\n        selectInput(\n            inputId  = \"linetype_input\",\n            label    = \"Linetype\",\n            choices  = c(\"solid\", \"dashed\", \"dotted\",\n                         \"dotdash\", \"longdash\", \"twodash\"),\n            selected = \"solid\"\n        ),\n        sliderInput(\n            inputId = \"linewidth_input\",\n            label   = \"Linewidth\",\n            min     = 0,\n            max     = 4,\n            value   = 1,\n            step    = .5\n        ),\n        checkboxInput(\n            inputId = \"fill_input\",\n            label   = \"Rellenar?\",\n            value   = FALSE\n        )\n    ),\n    verbatimTextOutput(\"code\") |&gt; card(),\n    plotOutput(\"plot\", width = 500) |&gt; card()\n)\n\n## Server\nserver &lt;- function(input, output, session) {\n    \n    output$code &lt;- renderPrint({\n        \n        if (input$fill_input) {\n            glue(\n            'ggplot(iris, aes(x = Petal.Length)) +\n                geom_density(\n                    color     = \"darkred\",\n                    fill      = \"gray30\",\n                    linetype  = \"{input$linetype_input}\",\n                    linewidth = {input$linewidth_input}\n                ) +\n                labs(\n                    title = \"Distribución de longitud del pétalo\", \n                    x     = \"Longitud (mm)\", \n                    y     = \"Probabilidad (%)\"\n                ) +\n                theme_bw(base_size = 8)'\n            )\n        } else {\n            glue(\n            'ggplot(iris, aes(x = Petal.Length)) +\n                geom_density(\n                    color     = \"darkred\",\n                    linetype  = \"{input$linetype_input}\",\n                    linewidth = {input$linewidth_input}\n                ) +\n                labs(\n                    title = \"Distribución de longitud del pétalo\", \n                    x     = \"Longitud (mm)\", \n                    y     = \"Probabilidad (%)\"\n                ) +\n                theme_bw()'\n            )\n        }\n    })\n\n    ## Plot\n    output$plot &lt;- renderPlot({\n        ggplot(iris, aes(x = Petal.Length)) +\n            geom_density(\n                color     = \"darkred\",\n                linetype  = input$linetype_input,\n                linewidth = input$linewidth_input,\n                fill      = if (input$fill_input) \"gray30\" else NA\n            ) +\n            labs(\n                title = \"Distribución de longitud del pétalo\", \n                x     = \"Longitud (mm)\", \n                y     = \"Probabilidad (%)\"\n            ) +\n            theme_bw(base_size = 8)\n    }, res = 96)\n}\n\n## Run app\nshinyApp(ui = ui, server = server)\n\n4.3.1 Ejercicio 1\nFinalmente, al igual que con los histogramas, podemos comparar la distribución de la longitud del pétalo entre las diferentes especies de flores del dataset iris. Te atreves a intentar añadir la parte del código que falta? El resultado debería ser el indicado en la Figura 4.2:\n\n\n\n\n\n\n\nFig. 4.2: Resultado del ejercicio 1\n\n\n\n\nEn total hay que añadir tres elementos:\n\nTransparencia (necesaria para poder ver la superposición de densidades)\nEliminar color de contorno\nCrear un gráfico de densidad por especie dentro del mismo gráfico\n\n\n\nEjercicio 1\nSolución\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nEl argumento aes(fill = Species) también se puede introducir en la función ggplot().\nggplot(iris, aes(x = Petal.Length)) +\n    geom_density(\n        aes(fill = Species),\n        color    = NA,\n        alpha    = .8\n    ) +\n    labs(\n        title = \"Distribución de longitud del pétalo\",\n        x     = \"Longitud (mm)\", \n        y     = \"Probabilidad (%)\"\n    ) +\n    theme_bw()\n\n\n\n\n4.3.2 Ejercicio 2\nEn los siguientes ejercicios vamos a trabajar con los datos de inventario. Vamos a empezar cargando los datos, convertirlos a tibble y vamos a ver de nuevo su estructura:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nEl ejercicio consiste en generar un histograma de la distribución diamétrica (en centímetros), además generando un gráfico por especie. Utiliza el siguiente bloque de código y practica todo lo que hemos visto hasta ahora:\n\n\nEjercicio 2\nResultado\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nEl siguiente código es una de muchas opciones.\n\nCódigoggplot(\n    inventario_tbl, \n    aes(x = dbh_mm / 10, fill = nombre_ifn)\n) +\n    geom_histogram(\n        bins  = 25, \n        color = \"snow\"\n    ) +\n    labs(\n        title = \"Distribución diamétrica por especie\",\n        x     = \"Diámetro (cm)\", \n        y     = \"Frecuencia\",\n        fill  = \"Especie\"\n    ) +\n    theme_minimal()\n\n\n\n\n\n\nFig. 4.3: Resultado del ejercicio 2\n\n\n\n\n\n\n\nEn la Figura 4.3 hemos añadido el argumento fill dentro de la función labs(). Cuando utilizamos una estética como color, fill, shape… dentro de aes(), podemos utilizar el nombre de esta estética dentro de labs() para modificar el título de la leyenda.\n\n4.3.3 Ejercicio 3\nGenerar un gráfico de densidad para la altura de los árboles por especie.\n\n\nEjercicio 3\nResultado\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nEl siguiente código es una de muchas opciones.\n\nCódigoggplot(\n    inventario_tbl, \n    aes(x = height_m, fill = nombre_ifn)\n) +\n    geom_density(\n        alpha = .7\n    ) +\n    labs(\n        title = \"Distribución de alturas por especie\",\n        x     = \"Altura (m)\", \n        y     = \"Probabilidad (%)\",\n        fill  = \"Especie\"\n    ) +\n    theme_minimal()\n\n\n\n\n\n\nFig. 4.4: Resultado del ejercicio 3\n\n\n\n\n\n\n\n\n4.3.4 Extra - Añadir líneas\nAlgo común es añadir líneas a los gráficos que representen algún valor importante como la media o la mediana. En esta breve sección vamos a ver como añadir estas dos líneas a un histograma.\nVamos a empezar con un histograma de la distribución diamétrica de P. sylvestris:\n\nCódigoinventario_tbl |&gt; \n    filter(nombre_ifn == \"Pinus sylvestris\") |&gt; \n    ggplot(\n        aes(x = dbh_mm)\n    ) +\n    geom_histogram(\n        color = \"snow\",\n        fill  = \"#0073C2FF\"\n    ) +\n    theme_bw()\n\n\n\n\n\n\nFig. 4.5: Distribución diamétrica de Pinus sylvestris\n\n\n\n\nLa idea es añadir una línea vertical que nos señale donde se encuentran la media y la mediana. Para ello, tenemos la función geom_vline(). El argumento más importante es:\n\n\nxintercept: valor en el eje x donde se va a situar la línea.\n\nEl resto de argumentos pueden consultarse en la documentación de la función, y serán los comunes a geometrías de línea: color, linewidth, linetype…\n\nCódigo## Filtrar datos de Pinus sylvestris\n## Crear columna de diámetro en cm\npsylvestris_tbl &lt;- inventario_tbl |&gt; \n    filter(nombre_ifn == \"Pinus sylvestris\") |&gt; \n    mutate(\n        dbh_cm = dbh_mm / 10\n    )\n    \n## Gráfico\npsylvestris_tbl |&gt; \n    ggplot(\n        aes(x = dbh_cm)\n    ) +\n    geom_histogram(\n        color = \"snow\",\n        fill  = \"#0073C2FF\",\n        alpha = .7  \n    ) +\n    geom_vline(\n        aes(xintercept = mean(psylvestris_tbl$dbh_cm, na.rm = TRUE)),\n        color = \"darkred\",\n        size  = 1\n    ) +\n    geom_vline(\n        xintercept = median(psylvestris_tbl$dbh_cm, na.rm = TRUE),\n        color      = \"darkorange\",\n        size       = 1\n    ) +\n    labs(\n        title = \"Distribución diamétrica de Pinus sylvestris\",\n        x     = \"Diámetro (cm)\", \n        y     = \"Frecuencia\"\n    ) +\n    theme_bw()\n\n\n\n\n\n\nFig. 4.6: Distribución diamétrica de Pinus sylvestris con líneas\n\n\n\n\nComo solamente utilizamos un valor que generamos con mean() y median(), no es necesario utilizar aes() en geom_vline(). Se muestran ambas opciones para mostrar que es posible utilizar cualquiera de las dos opciones.",
    "crumbs": [
      "Tipos de visualización",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Gráficos de distribución</span>"
    ]
  },
  {
    "objectID": "1102_distribution.html#boxplot",
    "href": "1102_distribution.html#boxplot",
    "title": "4  Gráficos de distribución",
    "section": "\n4.4 Boxplot",
    "text": "4.4 Boxplot\nLos boxplot (gráficos de cajas o bigotes) son una forma de visualizar la distribución de una variable numérica. En un gráfico de cajas, se muestra un resumen de la distribución de los datos, incluyendo la mediana, los cuartiles y los valores atípicos. Los gráficos de cajas son útiles para identificar la presencia de valores atípicos y la simetría de la distribución.\n\n\n\n\n\nFig. 4.7: Partes de un boxplot. Fuente: R Graph Gallery\n\n\nAunque es un gráfico que nos da un resumen estadístico muy bueno, es un gráfico que nunca se debe utilizar solo. Un boxplot nos está mostrando cinco valores principales: mínimo, primer cuartil, mediana, tercer cuartil y máximo. Sin embargo, no sabemos nada del resto de valores. Fíjate en los siguientes boxplot:\n\n\n\n\n\n\n\nFig. 4.8: Boxplots con datos ficticios con la misma forma\n\n\n\n\nAmbos gráficos tienen exactamente la misma forma, pero como puedes ver en los puntos, los datos son muy distintos. Es por ello que se suelen utilizar variantes del boxplot o el boxplot combinado con otras geometrías como el violin plot.\nUna vez vista esta debilidad de los boxplot, vamos a generar uno para la distribución de la longitud de los pétalos del dataset de iris. En este caso, va a ser el primer gráfico de distribución donde utilicemos ambas estéticas de los ejes x e y.\nLa función geom_boxplot() tiene un montón de argumentos que podemos modificar. Los outliers se representan como puntos, y por ende, podemos modificar todo aquello relacionado con ellos con argumentos que empiezan por outlier.*. Por ejemplo, outlier.shape, outlier.size, outlier.color…\n\nCódigobase_boxplot &lt;- ggplot(iris, aes(x = Species, y = Petal.Length)) +\n    geom_boxplot(\n        fill          = \"orangered\",\n        alpha         = .4,\n        outlier.shape = 21,\n        outlier.size  = 3,\n        outlier.color = \"black\",\n        varwidth      = TRUE\n    ) +\n    labs(\n        title = \"Distribución de la longitud del pétalo por especie\",\n        x     = \"Especie\", \n        y     = \"Longitud (mm)\"\n    ) +\n    theme_minimal()\n    \nbase_boxplot\n\n\n\n\n\n\nFig. 4.9: Boxplot de la longitud del pétalo\n\n\n\n\nHemos guardo el gráfico en un objeto llamado base_boxplot para poder añadir más elementos en la siguiente sección.\n\n4.4.1 Boxplot + Jitter\nPara añadir la distribución de los datos en un boxplot, podemos utilizar la función geom_point():\n\nCódigobase_boxplot +\n    geom_point()\n\n\n\n\n\n\nFig. 4.10: Boxplot de la longitud del pétalo con geom_point()\n\n\n\n\nSin embargo, como puedes ver, los puntos están superpuestos. Para evitar esto, podemos utilizar la función position_jitter() dentro del argumento position que nos permite añadir un poco de ruido a los puntos para que no se superpongan. Esto significa que los puntos tendrán un determinando porcentaje (0-1) de variación en el eje x con el argumento width y en el eje y con el argumento height. Utiliza la siguiente herramienta para ver como funciona:\n#| standalone: true\n#| viewerHeight: 600\n\n## Load packages\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(glue)\nlibrary(shiny)\n\n## UI\nui &lt;- page_sidebar(\n    sidebar = sidebar(\n        open = \"open\",\n        width = 200,\n        sliderInput(\"width_j\", \"Width\", min = 0, max = 1, value = .5, step = .1),\n        sliderInput(\"height_j\", \"Height\", min = 0, max = 1, value = .5, step = .1)\n    ),\n    verbatimTextOutput(\"code\") |&gt; card(),\n    plotOutput(\"plot\", width = 500) |&gt; card()\n)\n\n## Server\nserver &lt;- function(input, output, session) {\n    \n    output$code &lt;- renderPrint({\n        glue(\n            '\n            base_boxplot +\n                geom_point(\n                    position = position_jitter(\n                        width  = {input$width_j},\n                        height = {input$height_j}\n                    ),\n                    alpha    = .7\n                )'\n            )\n    })\n\n    ## Plot\n    output$plot &lt;- renderPlot({\n        ggplot(iris, aes(x = Species, y = Petal.Length)) +\n            geom_boxplot(\n                fill          = \"orangered\",\n                alpha         = .4,\n                outlier.shape = 21,\n                outlier.size  = 3,\n                outlier.color = \"black\",\n                varwidth      = TRUE\n            ) +\n            labs(\n                title = \"Distribución de la longitud del pétalo por especie\",\n                x     = \"Especie\", \n                y     = \"Longitud (mm)\"\n            ) +\n            theme_minimal() +\n                        geom_point(\n                            position = position_jitter(\n                                width  = {input$width_j},\n                                height = {input$height_j}\n                            ),\n                            alpha    = .7\n                        ) +\n                    theme_gray(base_size = 8)\n    }, res = 96)\n}\n\n## Run app\nshinyApp(ui = ui, server = server)\nSi ambos son igual a 0, significa que no se añade ruido. si aumentamos width, veremos que los datos se mantienen en sus valores originales según la variable de longitud del pétalo, pero se mueven aleatoriamente a lo largo del eje x. De este modo podemos ver mejor la distribución. No obstante, esto es recomendable solamente en variables categóricas para que los puntos no estén unos encima de otros. En variables numéricas no tiene sentido ya que estamos modificando los datos. Es decir, en este ejemplo height debe ser igual a 0.\n\n\n\n\n\n\nNota\n\n\n\nSi utilizamos un valor igual o superior a 0.5 los puntos de distintas categorías se superpondrán.\n\n\nComo esta geometría es muy común, ggplot2 tiene la función geom_jitter() que es un atajo para geom_point(position = position_jitter()):\n\nCódigobase_boxplot +\n    geom_jitter(height = 0, width = .2)\n\n\n\n\n\n\nFig. 4.11: Boxplot de la longitud del pétalo con geom_jitter()\n\n\n\n\n\n4.4.2 Ejercicio 4\nGenerar un boxplot de la distribución diamétrica por especie. Además, añadir la distribución de los puntos. Para practicar, utiliza la documentación de geom_boxplot() para modificar distintos argumentos.\n\n\nEjercicio 4\nResultado\nViolin plot\nResumen\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nEl siguiente código es una de muchas opciones.\n\nCódigo## Crear boxplot\nggplot(\n    inventario_tbl, \n    aes(x = nombre_ifn, y = dbh_mm / 10)\n) +\n    geom_boxplot(\n        fill          = \"#82BE1F\",\n        outlier.shape = 21,\n        outlier.size  = 3,\n        outlier.fill  = \"#E121DB\",\n        varwidth      = TRUE,\n        width         = .5\n    ) +\n    geom_jitter(\n        color = \"#7D9E69\",\n        height = 0,\n        width  = .4,\n        alpha  = .3\n    ) +\n    labs(\n        title = \"Distribución diamétrica por especie\",\n        x     = \"Especie\", \n        y     = \"Diámetro (cm)\"\n    ) +\n    theme_minimal()\n\n\n\n\n\n\nFig. 4.12: Resultado del ejercicio 4\n\n\n\n\n\n4.4.3 Extra - Añadir media\nTambién es posible añadir la localización de la media mediante un punto en un boxplot. Para ello, utilizamos la función geom_point():\n\nCódigobase_boxplot +\n    geom_point()\n\n\n\n\n\n\n\nBueeeno 😅… Recuerdas cuándo hablábamos de las transformaciones estadísticas en Sección 2.4? Pues por defecto geom_point() utiliza stat = \"identity\", que quería decir que no se aplica ninguna transformación, y por lo tanto \\(f(x) = x\\). Será ggplot2 tan mágico que nos dejará decir que realice una transformación estadística en la que convierta los puntos a la media? Sí, pero debemos utilizar la transformación estadística summary, y elegir una función de resumen con el argumento fun. En realidad, podemos añadir varias funciones que puedes probar aquí:\n#| standalone: true\n#| viewerHeight: 600\n\n## Load packages\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(glue)\nlibrary(shiny)\n\n## UI\nui &lt;- page_sidebar(\n    sidebar = sidebar(\n        open = \"open\",\n        width = 200,\n        selectInput(\n            inputId = \"fun_input\", \n            label   = \"Función\", \n            choices = c(\"min\", \"max\", \"mean\", \"median\", \"quantile\")\n        )\n    ),\n    verbatimTextOutput(\"code\") |&gt; card(),\n    plotOutput(\"plot\", width = 500) |&gt; card()\n)\n\n## Server\nserver &lt;- function(input, output, session) {\n    \n    output$code &lt;- renderPrint({\n        glue(\n            '\n            base_boxplot +\n                geom_point(\n                    stat  = \"summary\",\n                    fun   = {input$fun_input},\n                    shape = 4,\n                    size  = 3,\n                    color = \"red\"\n                )'\n            )\n    })\n\n    ## Plot\n    output$plot &lt;- renderPlot({\n        ggplot(iris, aes(x = Species, y = Petal.Length)) +\n            geom_boxplot(\n                fill          = \"orangered\",\n                alpha         = .4,\n                outlier.shape = 21,\n                outlier.size  = 3,\n                outlier.color = \"black\",\n                varwidth      = TRUE\n            ) +\n            labs(\n                title = \"Distribución de la longitud del pétalo por especie\",\n                x     = \"Especie\", \n                y     = \"Longitud (mm)\"\n            ) +\n            theme_minimal() +\n            geom_point(\n                stat  = \"summary\",\n                fun   = {input$fun_input},\n                shape = 4,\n                size  = 3,\n                color = \"red\"\n            ) +\n            theme_gray(base_size = 8)\n    }, res = 96)\n}\n\n## Run app\nshinyApp(ui = ui, server = server)\nCualquier función que se pueda aplicar a un vector numérico, se puede añadir dentro del argumento fun, y esto incluye funciones personalizadas.\n\n\n\n\n\n\nTip\n\n\n\nSi quieres ver las opciones del argumento shape, puedes consultar la documentación de la función points().\n\n\n\n\n\nEl violin plot es una forma de visualizar la distribución de una variable numérica. A diferencia del boxplot, el violin plot muestra la distribución de los datos de forma más detallada, de forma que no es necesario añadir una capa de puntos jitter para tener una idea de la distribución de los datos.\n\nCódigobase_violin &lt;- ggplot(iris, aes(x = Species, y = Petal.Length)) +\n  geom_violin(\n      fill  = \"#0073C2FF\",\n      color = \"white\"\n  ) +\n  labs(\n      title = \"Distribución de la longitud del pétalo por especie\",\n      x     = \"Especie\", \n      y     = \"Longitud (mm)\"\n  ) +\n  theme_minimal()\n  \nbase_violin\n\n\n\n\n\n\nFig. 4.13: Violin plot de la longitud del pétalo\n\n\n\n\nEn la Figura 4.13 vemos que los gráficos son más o menos anchos. Cuanto más anchos, más datos hay en esa zona. Para tener una idea de lo que significa, podemos añadir una capa de puntos y así entenderlo mejor:\n\nCódigobase_violin +\n  geom_jitter(\n      alpha  = .5,\n      height = 0\n  ) \n\n\n\n\n\n\nFig. 4.14: Violin plot de la longitud del pétalo con geom_jitter()\n\n\n\n\nComo puedes ver, los puntos se distribuyen en función de la anchura del violin plot. Si la anchura es mayor, significa que hay más datos en esa zona.\nOpciones interesantes para modificar el violin plot son:\n\ntrim: si es FALSE, el violin plot se extenderá hasta los valores extremos de los datos. Si es TRUE (por defecto), se extenderá hasta el valor más extremo que no sea un valor atípico.\nscale: si es area (por defecto), el área de cada violin es proporcional al número de observaciones. Si es count, el ancho de cada violin es proporcional al número de observaciones.\ndraw_quantiles: si es TRUE, se dibujarán los cuantiles del 25%, 50% y 75% en el violin plot.\n\n\nCódigoggplot(iris, aes(x = Species, y = Petal.Length)) +\n  geom_violin(\n      fill  = \"#0073C2FF\",\n      color = \"white\",\n      trim  = TRUE,\n      scale = \"area\",\n      draw_quantiles = c(.25, .5, .75),\n  ) +\n  labs(\n      title = \"Distribución de la longitud del pétalo por especie\",\n      x     = \"Especie\", \n      y     = \"Longitud (mm)\"\n  ) +\n  theme_minimal()\n\n\n\n\n\n\nFig. 4.15: Violin plot de la longitud del pétalo con opciones\n\n\n\n\n\n4.4.4 Ejercicio 5\nGenerar un violin plot de la distribución diamétrica por especie de inventario_tbl. Además, añadir una capa de puntos para ver la distribución de los datos. Visualizar la diferencia entre scale = \"area\" y scale = \"count\" y quedarse con el que te parezca más adecuado (en la pestaña “Resultado” se explica cuál es la mejor opción).\nEl resultado de este ejercicio lo utilizaremos en Sección 4.4.5, así que guarda el violin plot en un objeto llamado violin_ej5_gg.\n\n\nEjercicio 5\nResultado\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nEl siguiente código es una de muchas opciones.\nCon scale = \"count\", vemos que de P. sylvestris tenemos muchos más datos. Si utilizamos scale = \"area, esto no lo sabemos. Por lo tanto, es mejor utilizar scale = \"count\".\n\nCódigo## Crear violin plot\nviolin_ej5_gg &lt;- ggplot(\n    inventario_tbl, \n    aes(x = nombre_ifn, y = dbh_mm / 10)\n) +\n    geom_violin(\n        fill  = \"#82BE1F\",\n        color = \"transparent\",\n        trim  = TRUE,\n        scale = \"count\"\n    ) +\n    labs(\n        title = \"Distribución diamétrica por especie\",\n        x     = \"Especie\", \n        y     = \"Diámetro (cm)\"\n    ) +\n    theme_bw()\n## Imprimir\nviolin_ej5_gg\n\n\n\n\n\n\nFig. 4.16: Resultado del ejercicio 5\n\n\n\n\n\n\n\n\n4.4.5 Ejercicio 6\nEn la Sección 4.4.4 hemos generado un diamétrica por especie que guardamos como violin_ej5_gg. A este gráfico, añadir un boxplot y un punto que represente la media de la distribución.\n\n\nEjercicio 6\nResultado\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nEl siguiente código es una de muchas opciones.\n\nCódigoviolin_ej5_gg +\n    geom_boxplot(\n        fill          = \"transparent\",\n        outliers      = FALSE,\n        varwidth      = TRUE,\n        width         = .2\n    ) +\n    geom_point(\n        stat  = \"summary\",\n        fun   = \"mean\",\n        shape = 19,\n        size  = 3,\n        color = \"red\"\n    )\n\n\n\n\n\n\nFig. 4.17: Resultado del ejercicio 6\n\n\n\n\n\n\n\nEnhorabuena! Has llegado al final de la sección de distribuciones. En la siguiente sección vamos a ver cómo podemos comparar distribuciones entre diferentes grupos.\n\n\n\nEn esta sección hemos aprendido a visualizar la distribución de una variable numérica utilizando distintos tipos de gráficos. Hemos visto cómo crear histogramas, gráficos de densidad, boxplots y violin plots. Además, hemos aprendido a añadir capas de puntos a los gráficos para ver la distribución de los datos, resúmenes estadísticos como la media y a modificar distintos argumentos de las geometrías.",
    "crumbs": [
      "Tipos de visualización",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Gráficos de distribución</span>"
    ]
  },
  {
    "objectID": "chapters/installation.html",
    "href": "chapters/installation.html",
    "title": "Apéndice A — Instalación",
    "section": "",
    "text": "Para instalar R …",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Instalación</span>"
    ]
  },
  {
    "objectID": "1001_visualization.html",
    "href": "1001_visualization.html",
    "title": "Visualización",
    "section": "",
    "text": "Objetivos",
    "crumbs": [
      "Visualización"
    ]
  },
  {
    "objectID": "1001_visualization.html#objetivos",
    "href": "1001_visualization.html#objetivos",
    "title": "Visualización",
    "section": "",
    "text": "Entender la necesidad de comunicar nuestros datos de una forma clara\nAprender algunos de los principios de la visualización de datos\nAprender a elegir el gráfico adecuado para nuestros datos y nuestros objetivos\nEntender la gramática de gráficos y su implicación dentro de {ggplot2}\nCrear gráficos sencillos pero comunicativos con {ggplot2}",
    "crumbs": [
      "Visualización"
    ]
  },
  {
    "objectID": "1101_visualization_types.html",
    "href": "1101_visualization_types.html",
    "title": "Tipos de visualización",
    "section": "",
    "text": "En los siguientes capítulos nos introduciremos en los tipos de visualización más comunes en el análisis de datos. Existen muchas formas de crear una jerarquía de tipos de visualización, pero en este curso nos enfocaremos en una clasificación según el tipo de visualización y la cantidad de variables que se desean representar. En este sentido, la Figura 1 muestra una clasificación de algunas de las visualizaciones más comunes y que veremos a lo largo del curso.\n\n\n\n\n\nFig. 1: Clasificación de los tipos de visualización. Fuente: Cédric Scherer, rstudio::conf 2022\n\n\nEn los ejercicios de muestra, trabajaremos con el dataset de iris, que viene dentro del paquete {datasets} de R. Este dataset contiene información sobre 150 flores de iris, con 4 variables numéricas y una variable categórica que indica la especie de la flor Figura 2.\n\n\n\n\n\nFig. 2: Especies de flores del dataset iris. Fuente: Datacamp\n\n\nA continuación mostramos la estructura del dataset utilizando la función {skimr::skim}:\n\nCódigoskim(iris)\n\n\nData summary\n\n\nName\niris\n\n\nNumber of rows\n150\n\n\nNumber of columns\n5\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nfactor\n1\n\n\nnumeric\n4\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: factor\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nordered\nn_unique\ntop_counts\n\n\nSpecies\n0\n1\nFALSE\n3\nset: 50, ver: 50, vir: 50\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\nSepal.Length\n0\n1\n5.84\n0.83\n4.3\n5.1\n5.80\n6.4\n7.9\n▆▇▇▅▂\n\n\nSepal.Width\n0\n1\n3.06\n0.44\n2.0\n2.8\n3.00\n3.3\n4.4\n▁▆▇▂▁\n\n\nPetal.Length\n0\n1\n3.76\n1.77\n1.0\n1.6\n4.35\n5.1\n6.9\n▇▁▆▇▂\n\n\nPetal.Width\n0\n1\n1.20\n0.76\n0.1\n0.3\n1.30\n1.8\n2.5\n▇▁▇▅▃\n\n\n\n\n\nEn resumen, tenemos 50 muestras de cada una de las tres especies (I. versicolor, I. setosa y I. virginica) a las cuales hemos medido cuatro variables cuantitativas.",
    "crumbs": [
      "Tipos de visualización"
    ]
  }
]