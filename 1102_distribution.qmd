---
## Base opts
execute: 
  warning: false
editor_options: 
  chunk_output_type: console
## Extensions
filters: 
    - webr
webr:
    packages: ["ggplot2"]
---

# Gr√°ficos de distribuci√≥n {#sec-plot-distribution}

Los gr√°ficos de distribuci√≥n son una forma de visualizar la distribuci√≥n de los datos. En este tipo de gr√°ficos, se muestra la frecuencia de los valores de una variable o de un conjunto de variables. Los gr√°ficos de distribuci√≥n son √∫tiles para identificar patrones en los datos, como la presencia de valores at√≠picos, la simetr√≠a de la distribuci√≥n, la presencia de m√∫ltiples modas, entre otros. Generalmente, los gr√°ficos de distribuci√≥n se utilizan para visualizar **una sola variable num√©rica** aunque en la @fig-vis-classification se muestra que tambi√©n es posible visualizar **dos variables num√©ricas** mediante el uso de gr√°ficos de dispersi√≥n (**scatter plot**).

En este cap√≠tulo, veremos los siguientes tipos de gr√°ficos de distribuci√≥n:

1.  Histogramas (**histogram**)

2.  Gr√°ficos de densidad (**density plot**)

3.  Gr√°ficos de cajas (**box plot**)

4.  Gr√°ficos de viol√≠n (**violin plot**)

::: callout-info
Los gr√°ficos de dispersi√≥n los veremos dentro del cap√≠tulo de gr√°ficos de relaci√≥n.
:::

En este cap√≠tulo vamos a trabajar con dos datasets:

-   `iris`: se utilizar√° para los ejemplos utilizados en las explicaciones (ver [Tipos de visualizaci√≥n](#sec-visualization-types){target="_blank"}).

-   `inventario`: ser√°n los datos que utilizar√°n los alumnos para los ejercicios propuestos (ver @sec-vis-data).

Para comenzar, vamos a cargar los paquetes necesarios y a leer los datos que utilizaremos en este cap√≠tulo.

```{r}
# Cargar paquetes
library(readr)
library(ggplot2)
# Cargar datos
inventario_tbl <- read_rds("data/inventario_prep.rds")
```

## Objetivos

Al final de este cap√≠tulo, ser√°s capaz de:

-   Crear histogramas en `{ggplot2}`

-   Crear gr√°ficos de densidad en `{ggplot2}`

-   Crear gr√°ficos de cajas en `{ggplot2}`

-   Crear gr√°ficos de viol√≠n en `{ggplot2}`

-   Utilizar etiquetas y temas predise√±ados en `{ggplot2}`

## Histogramas

Los histogramas son una forma de visualizar la distribuci√≥n de una variable num√©rica. En un histograma, los valores de la variable se agrupan en intervalos y se muestra la frecuencia de los valores en cada intervalo. Los histogramas son √∫tiles para identificar la forma de la distribuci√≥n de los datos, la presencia de valores at√≠picos y la presencia de m√∫ltiples modas.

Para crear un histograma en `ggplot2`, utilizamos la funci√≥n `geom_histogram()`. Tiene dos argumentos de gran importancia:

-   `bins`: n√∫mero de intervalos en los que se agrupar√°n los datos. Si no se especifica, `{ggplot2}` utilizar√° 30 intervalos.

-   `binwidth`: ancho de los intervalos. Si se especifica, `{ggplot2}` calcular√° el n√∫mero de intervalos autom√°ticamente.

::: callout-note
Estos dos argumentos son mutuamente excluyentes. Si se especifica `bins`, `{ggplot2}` ignorar√° `binwidth`.
:::

Vamos a ver la diferencia entre estos dos argumentos viendo la distribuci√≥n de la longitud de los p√©talos de las flores del dataset `iris`:

::: panel-tabset
## N√∫mero de intervalos

Al especificar el n√∫mero de intervalos lo que hacemos es b√°sicamente indicar el n√∫mero de barras que queremos generar:

```{shinylive-r}
#| standalone: true
#| viewerHeight: 500

## Load packages
library(bslib)
library(ggplot2)
library(glue)
library(shiny)

## UI
ui <- page_sidebar(
    sidebar = sidebar(
        open = "open",
        width = 200,
        sliderInput("bins", "N√∫mero de intervalos", min = 1, max = 30, value = 15),
    ),
    verbatimTextOutput("code") |> card(),
    plotOutput("plot", width = 500) |> card()
)

## Server
server <- function(input, output, session) {
    
    output$code <- renderPrint({
        glue(
            'ggplot(iris, aes(x = Petal.Length)) +
                    geom_histogram(bins = {input$bins}, fill = "#0073C2FF", color = "white") +
                    labs(
                        title = "Distribuci√≥n de longitud del p√©talo", 
                        x = "Longitud (mm)", 
                        y = "Frecuencia"
                    )'
            )
    })

    ## Plot
    output$plot <- renderPlot({
        ggplot(iris, aes(x = Petal.Length)) +
            geom_histogram(bins = input$bins, fill = "#0073C2FF", color = "white") +
            labs(
                title = "Distribuci√≥n de longitud del p√©talo", 
                x = "Longitud (cm)", 
                y = "Frecuencia"
            ) +
            theme_gray(base_size = 8)
    }, res = 96)
}

## Run app
shinyApp(ui = ui, server = server)
```

## Ancho del intervalo

Cuando seleccionamos el ancho del intervalo (*binwidth*), estamos seleccionando el tama√±o del intervalo en las unidades de la variable que estamos evaluando. Por ejemplo, si seleccionamos un ancho de banda de 0.3 para la longitud del p√©talo, estamos indicando que cada barra agrupar√° observaciones de 3 en 3 mil√≠metros. De 0-0.3 tendremos el primer intervalo, de 0.3-0.6 el segundo, y as√≠ sucesivamente.

```{shinylive-r}
#| standalone: true
#| viewerHeight: 500

## Load packages
library(bslib)
library(ggplot2)
library(glue)
library(shiny)

## UI
ui <- page_sidebar(
    sidebar = sidebar(
        open = "open",
        width = 200,
        sliderInput("bins", "Ancho del intervalo", min = 0.1, max = 2, value = .2, step = .1),
    ),
    verbatimTextOutput("code") |> card(),
    plotOutput("plot", width = 500) |> card()
)

## Server
server <- function(input, output, session) {
    
    output$code <- renderPrint({
        glue(
            '
            ggplot(iris, aes(x = Petal.Length)) +
                    geom_histogram(binwidth = {input$bins}, fill = "#0073C2FF", color = "white") +
                    labs(
                        title = "Distribuci√≥n de longitud del p√©talo", 
                        x = "Longitud (mm)", 
                        y = "Frecuencia"
                    )'
            )
    })

    ## Plot
    output$plot <- renderPlot({
        ggplot(iris, aes(x = Petal.Length)) +
            geom_histogram(binwidth = input$bins, fill = "#0073C2FF", color = "white") +
            labs(
                title = "Distribuci√≥n de longitud del p√©talo", 
                x     = "Longitud (mm)", 
                y     = "Frecuencia"
            ) +
            theme_gray(base_size = 8)
    }, res = 96)
}

## Run app
shinyApp(ui = ui, server = server)
```
:::

Un histograma es b√°sicamente esto. Para el color de relleno utilizamos el argumento `fill` y para el color del contorno utilizamos el argumento `color`, y este patr√≥n seguir√° siendo el mismo para los otros tipos de gr√°ficos de `{ggplot2}`.

Tambi√©n te habr√°s dado cuenta que hemos a√±adido una funci√≥n nueva que es `labs()`. Esta funci√≥n nos permite a√±adir etiquetas al gr√°fico como:

-   `title`: t√≠tulo del gr√°fico.

-   `subtitle`: subtitulo del gr√°fico.

-   `x`: t√≠tulo del eje x.

-   `y`: t√≠tulo del eje y.

-   `caption`: pie de figura.

Si bien es cierto que los histogramas son una forma de visualizar la distribuci√≥n de una sola variable, tambi√©n podemos crear histogramas para comparar la distribuci√≥n de una variable num√©rica entre diferentes grupos. Esto puede ser muy conveniente, ya que si nos fijamos en las figuras anteriores, podemos ver que si indicamos el n√∫mero de intervalos adecuado sigue una [distribuci√≥n bimodal](#0){target="_blank"}.

Vamos a ver qu√© pasa si comparamos la distribuci√≥n de la longitud de los p√©talos de las flores del *dataset* `iris` entre las diferentes especies de flores. Para ello, utilizamos el argumento `fill` en la funci√≥n `aes()` para indicar la variable categ√≥rica que queremos comparar:

```{r}
#| label: fig-distribution-species
#| fig-cap: Distribuci√≥n de longitud del p√©talo por especie
ggplot(iris, aes(x = Petal.Length, fill = Species)) +
    geom_histogram(bins = 30, color = "white") +
    labs(
        title    = "Distribuci√≥n de longitud del p√©talo por especie", 
        subtitle = "La especie I. setosa tiene una longitud de p√©talo menor que I. versicolor e I. virginica",
        x        = "Longitud (mm)", 
        y        = "Frecuencia",
        caption  = "Autor: Adri√°n Cidre"
    ) +
    theme_minimal()
```

Ah√° ü§î! Gracias a utilizar una est√©tica m√°s podemos ver que la distribuci√≥n no es bimodal, si no que son distribuciones de especies de flores distintas. En esencia, a√±adir una est√©tica m√°s puede ser visto como a√±adir una dimensi√≥n m√°s al gr√°fico.

::: callout-note
A partir de ahora vamos a ir a√±adiendo nuevas funciones y argumentos a nuestros gr√°ficos. No te preocupes si no entiendes todo a la primera, poco a poco iremos viendo c√≥mo se utilizan y para qu√© sirven. En este caso hemos a√±adido `theme_minimal()` que nos permite cambiar el tema base del gr√°fico. Existen una serie de temas predefinidos que empiezan por `theme_*()`.
:::

## Gr√°ficos de densidad

Los gr√°ficos de densidad son una forma de visualizar la distribuci√≥n de una variable num√©rica. A diferencia de los histogramas, los gr√°ficos de densidad no agrupan los datos en intervalos, sino que muestran la estimaci√≥n de densidad kernel de los datos. Los gr√°ficos de densidad son √∫tiles para identificar la forma de la distribuci√≥n de los datos, ya que son una versi√≥n suavizada de los histogramas.

Para crear un gr√°fico de densidad en `{ggplot2}`, utilizamos la funci√≥n `geom_density()`. B√°sicamente, se va a generar una l√≠nea que nos va a indicar la densidad de probabilidad de los datos. Como es una l√≠nea, tiene una serie de est√©ticas que podemos modificar a continuaci√≥n:

```{shinylive-r}
#| standalone: true
#| viewerHeight: 500

## Load packages
library(bslib)
library(ggplot2)
library(glue)
library(shiny)

## UI
ui <- page_sidebar(
    sidebar = sidebar(
        open  = "open",
        width = 200,
        selectInput(
            inputId  = "linetype_input",
            label    = "Linetype",
            choices  = c("solid", "dashed", "dotted",
                         "dotdash", "longdash", "twodash"),
            selected = "solid"
        ),
        sliderInput(
            inputId = "linewidth_input",
            label   = "Linewidth",
            min     = 0,
            max     = 4,
            value   = 1,
            step    = .5
        ),
        checkboxInput(
            inputId = "fill_input",
            label   = "Rellenar?",
            value   = FALSE
        )
    ),
    verbatimTextOutput("code") |> card(),
    plotOutput("plot", width = 500) |> card()
)

## Server
server <- function(input, output, session) {
    
    output$code <- renderPrint({
        
        if (input$fill_input) {
            glue(
            'ggplot(iris, aes(x = Petal.Length)) +
                geom_density(
                    color     = "darkred",
                    fill      = "gray30",
                    linetype  = "{input$linetype_input}",
                    linewidth = {input$linewidth_input}
                ) +
                labs(
                    title = "Distribuci√≥n de longitud del p√©talo", 
                    x     = "Longitud (mm)", 
                    y     = "Probabilidad (%)"
                ) +
                theme_bw(base_size = 8)'
            )
        } else {
            glue(
            'ggplot(iris, aes(x = Petal.Length)) +
                geom_density(
                    color     = "darkred",
                    linetype  = "{input$linetype_input}",
                    linewidth = {input$linewidth_input}
                ) +
                labs(
                    title = "Distribuci√≥n de longitud del p√©talo", 
                    x     = "Longitud (mm)", 
                    y     = "Probabilidad (%)"
                ) +
                theme_bw()'
            )
        }
    })

    ## Plot
    output$plot <- renderPlot({
        ggplot(iris, aes(x = Petal.Length)) +
            geom_density(
                color     = "darkred",
                linetype  = input$linetype_input,
                linewidth = input$linewidth_input,
                fill      = if (input$fill_input) "gray30" else NA
            ) +
            labs(
                title = "Distribuci√≥n de longitud del p√©talo", 
                x     = "Longitud (mm)", 
                y     = "Probabilidad (%)"
            ) +
            theme_bw(base_size = 8)
    }, res = 96)
}

## Run app
shinyApp(ui = ui, server = server)
```

### Ejercicio 1

Finalmente, al igual que con los histogramas, podemos comparar la distribuci√≥n de la longitud del p√©talo entre las diferentes especies de flores del *dataset* `iris`. Te atreves a intentar a√±adir la parte del c√≥digo que falta? El resultado deber√≠a ser el indicado en la @fig-distribution-ej1:

```{r}
#| label: fig-distribution-ej1
#| fig-cap: Resultado del ejercicio 1
#| echo: false
ggplot(iris, aes(x = Petal.Length)) +
    geom_density(
        aes(fill = Species),
        color    = NA,
        alpha    = .8
    ) +
    labs(
        title = "Distribuci√≥n de longitud del p√©talo",
        x     = "Longitud (mm)", 
        y     = "Probabilidad (%)"
    ) +
    theme_bw()
```

En total hay que a√±adir tres elementos:

-   Transparencia (necesaria para poder ver la superposici√≥n de densidades)

-   Eliminar color de contorno

-   Crear un gr√°fico de densidad por especie dentro del mismo gr√°fico

::: panel-tabset
## Ejercicio

```{webr-r}
ggplot(iris, aes(x = Petal.Length)) +
    geom_density() +
    labs(
        title = "Distribuci√≥n de longitud del p√©talo",
        x     = "Longitud (mm)", 
        y     = "Probabilidad (%)"
    ) +
    theme_bw()
```

## Soluci√≥n

El argumento `aes(fill = Species)` tambi√©n se puede introducir en la funci√≥n `ggplot()`.

```{.r}
ggplot(iris, aes(x = Petal.Length)) +
    geom_density(
        aes(fill = Species),
        color    = NA,
        alpha    = .8
    ) +
    labs(
        title = "Distribuci√≥n de longitud del p√©talo",
        x     = "Longitud (mm)", 
        y     = "Probabilidad (%)"
    ) +
    theme_bw()
```
:::



