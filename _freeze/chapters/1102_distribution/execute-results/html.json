{
  "hash": "59c96ba2cce869aba2785d3fbe6c4261",
  "result": {
    "engine": "knitr",
    "markdown": "---\nexecute: \n  warning: false\neditor_options: \n  chunk_output_type: console\nfilters: \n    - webr\nwebr:\n    packages: [\"dplyr\", \"ggplot2\"]\n---\n\n\n\n\n# Gr√°ficos de distribuci√≥n {#sec-plot-distribution}\n\nLos gr√°ficos de distribuci√≥n son una forma de visualizar la distribuci√≥n de los datos. En este tipo de gr√°ficos, se muestra la frecuencia de los valores de una variable o de un conjunto de variables. Los gr√°ficos de distribuci√≥n son √∫tiles para identificar patrones en los datos, como la presencia de valores at√≠picos, la simetr√≠a de la distribuci√≥n, la presencia de m√∫ltiples modas, entre otros. Generalmente, los gr√°ficos de distribuci√≥n se utilizan para visualizar **una sola variable num√©rica** aunque en la @fig-vis-classification se muestra que tambi√©n es posible visualizar **dos variables num√©ricas** mediante el uso de gr√°ficos de dispersi√≥n (**scatter plot**).\n\nEn este cap√≠tulo, veremos los siguientes tipos de gr√°ficos de distribuci√≥n:\n\n1.  Histogramas (**histogram**)\n\n2.  Gr√°ficos de densidad (**density plot**)\n\n3.  Gr√°ficos de cajas (**box plot**)\n\n4.  Gr√°ficos de viol√≠n (**violin plot**)\n\n::: callout-info\nLos gr√°ficos de dispersi√≥n los veremos dentro del cap√≠tulo de gr√°ficos de relaci√≥n.\n:::\n\nEn este cap√≠tulo vamos a trabajar con dos datasets:\n\n-   `iris`: se utilizar√° para los ejemplos utilizados en las explicaciones (ver [Tipos de visualizaci√≥n](#sec-visualization-types){target=\"_blank\"}).\n\n-   `inventario`: ser√°n los datos que utilizar√°n los alumnos para los ejercicios propuestos (ver @sec-vis-data).\n\nPara comenzar, vamos a cargar los paquetes necesarios y a leer los datos que utilizaremos en este cap√≠tulo.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Cargar paquetes\nlibrary(dplyr)\nlibrary(readr)\nlibrary(ggplot2)\n# Cargar datos\ninventario_tbl <- read_rds(\"../data/inventario_prep.rds\")\n```\n:::\n\n\n\n\n## Objetivos\n\nAl final de este cap√≠tulo, ser√°s capaz de:\n\n-   Utilizar etiquetas y temas predise√±ados en `{ggplot2}`\n\n-   Crear histogramas en `{ggplot2}`\n\n-   Crear gr√°ficos de densidad en `{ggplot2}`\n\n-   Crear gr√°ficos de cajas en `{ggplot2}`\n\n-   Crear gr√°ficos de viol√≠n en `{ggplot2}`\n\n-   A√±adir l√≠neas a los gr√°ficos\n\n-   A√±adir puntos con res√∫menes estad√≠sticos a los gr√°ficos\n\n## Histogramas\n\nLos histogramas son una forma de visualizar la distribuci√≥n de una variable num√©rica. En un histograma, los valores de la variable se agrupan en intervalos y se muestra la frecuencia de los valores en cada intervalo. Los histogramas son √∫tiles para identificar la forma de la distribuci√≥n de los datos, la presencia de valores at√≠picos y la presencia de m√∫ltiples modas.\n\nPara crear un histograma en `ggplot2`, utilizamos la funci√≥n `geom_histogram()`. Tiene dos argumentos de gran importancia:\n\n-   `bins`: n√∫mero de intervalos en los que se agrupar√°n los datos. Si no se especifica, `{ggplot2}` utilizar√° 30 intervalos.\n\n-   `binwidth`: ancho de los intervalos. Si se especifica, `{ggplot2}` calcular√° el n√∫mero de intervalos autom√°ticamente.\n\n::: callout-note\nEstos dos argumentos son mutuamente excluyentes. Si se especifica `bins`, `{ggplot2}` ignorar√° `binwidth`.\n:::\n\nVamos a ver la diferencia entre estos dos argumentos viendo la distribuci√≥n de la longitud de los p√©talos de las flores del dataset `iris`:\n\n::: panel-tabset\n## N√∫mero de intervalos\n\nAl especificar el n√∫mero de intervalos lo que hacemos es b√°sicamente indicar el n√∫mero de barras que queremos generar:\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 600\n\n## Load packages\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(glue)\nlibrary(shiny)\n\n## UI\nui <- page_sidebar(\n    sidebar = sidebar(\n        open = \"open\",\n        width = 200,\n        sliderInput(\"bins\", \"N√∫mero de intervalos\", min = 1, max = 30, value = 15),\n    ),\n    verbatimTextOutput(\"code\") |> card(),\n    plotOutput(\"plot\", width = 500) |> card()\n)\n\n## Server\nserver <- function(input, output, session) {\n    \n    output$code <- renderPrint({\n        glue(\n            'ggplot(iris, aes(x = Petal.Length)) +\n                    geom_histogram(bins = {input$bins}, fill = \"#0073C2FF\", color = \"white\") +\n                    labs(\n                        title = \"Distribuci√≥n de longitud del p√©talo\", \n                        x = \"Longitud (mm)\", \n                        y = \"Frecuencia\"\n                    )'\n            )\n    })\n\n    ## Plot\n    output$plot <- renderPlot({\n        ggplot(iris, aes(x = Petal.Length)) +\n            geom_histogram(bins = input$bins, fill = \"#0073C2FF\", color = \"white\") +\n            labs(\n                title = \"Distribuci√≥n de longitud del p√©talo\", \n                x = \"Longitud (cm)\", \n                y = \"Frecuencia\"\n            ) +\n            theme_gray(base_size = 8)\n    }, res = 96)\n}\n\n## Run app\nshinyApp(ui = ui, server = server)\n```\n\n## Ancho del intervalo\n\nCuando seleccionamos el ancho del intervalo (*binwidth*), estamos seleccionando el tama√±o del intervalo en las unidades de la variable que estamos evaluando. Por ejemplo, si seleccionamos un ancho de banda de 0.3 para la longitud del p√©talo, estamos indicando que cada barra agrupar√° observaciones de 3 en 3 mil√≠metros. De 0-0.3 tendremos el primer intervalo, de 0.3-0.6 el segundo, y as√≠ sucesivamente.\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 600\n\n## Load packages\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(glue)\nlibrary(shiny)\n\n## UI\nui <- page_sidebar(\n    sidebar = sidebar(\n        open = \"open\",\n        width = 200,\n        sliderInput(\"bins\", \"Ancho del intervalo\", min = 0.1, max = 2, value = .2, step = .1),\n    ),\n    verbatimTextOutput(\"code\") |> card(),\n    plotOutput(\"plot\", width = 500) |> card()\n)\n\n## Server\nserver <- function(input, output, session) {\n    \n    output$code <- renderPrint({\n        glue(\n            '\n            ggplot(iris, aes(x = Petal.Length)) +\n                    geom_histogram(binwidth = {input$bins}, fill = \"#0073C2FF\", color = \"white\") +\n                    labs(\n                        title = \"Distribuci√≥n de longitud del p√©talo\", \n                        x = \"Longitud (mm)\", \n                        y = \"Frecuencia\"\n                    )'\n            )\n    })\n\n    ## Plot\n    output$plot <- renderPlot({\n        ggplot(iris, aes(x = Petal.Length)) +\n            geom_histogram(binwidth = input$bins, fill = \"#0073C2FF\", color = \"white\") +\n            labs(\n                title = \"Distribuci√≥n de longitud del p√©talo\", \n                x     = \"Longitud (mm)\", \n                y     = \"Frecuencia\"\n            ) +\n            theme_gray(base_size = 8)\n    }, res = 96)\n}\n\n## Run app\nshinyApp(ui = ui, server = server)\n```\n:::\n\n::: callout-tip\nLos c√≥digos hexadecimales son una forma de representar colores en HTML y CSS. En R, podemos utilizarlos para cambiar el color de los gr√°ficos. En este caso, el color `#0073C2FF` representa un azul claro. Puedes utilizar generadores de colores online como [este](https://htmlcolorcodes.com/){target=\"_blank\"} para elegir un color.\n:::\n\nUn histograma es b√°sicamente esto. Para el color de relleno utilizamos el argumento `fill` y para el color del contorno utilizamos el argumento `color`, y este patr√≥n seguir√° siendo el mismo para los otros tipos de gr√°ficos de `{ggplot2}`.\n\nTambi√©n te habr√°s dado cuenta que hemos a√±adido una funci√≥n nueva que es `labs()`. Esta funci√≥n nos permite a√±adir etiquetas al gr√°fico como:\n\n-   `title`: t√≠tulo del gr√°fico.\n\n-   `subtitle`: subtitulo del gr√°fico.\n\n-   `x`: t√≠tulo del eje x.\n\n-   `y`: t√≠tulo del eje y.\n\n-   `caption`: pie de figura.\n\nSi bien es cierto que los histogramas son una forma de visualizar la distribuci√≥n de una sola variable, tambi√©n podemos crear histogramas para comparar la distribuci√≥n de una variable num√©rica entre diferentes grupos. Esto puede ser muy conveniente, ya que si nos fijamos en las figuras anteriores, podemos ver que si indicamos el n√∫mero de intervalos adecuado sigue una [distribuci√≥n bimodal](#0){target=\"_blank\"}.\n\nVamos a ver qu√© pasa si comparamos la distribuci√≥n de la longitud de los p√©talos de las flores del *dataset* `iris` entre las diferentes especies de flores. Para ello, utilizamos el argumento `fill` en la funci√≥n `aes()` para indicar la variable categ√≥rica que queremos comparar:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris |> \n    ggplot(\n        aes(x = Petal.Length, fill = Species)\n    ) +\n    geom_histogram(bins = 30, color = \"white\") +\n    labs(\n        title    = \"Distribuci√≥n de longitud del p√©talo por especie\", \n        subtitle = \"La especie I. setosa tiene una longitud de p√©talo menor que I. versicolor e I. virginica\",\n        x        = \"Longitud (mm)\", \n        y        = \"Frecuencia\",\n        caption  = \"Autor: Adri√°n Cidre\"\n    ) +\n    theme_minimal()\n```\n\n::: {.cell-output-display}\n![Distribuci√≥n de longitud del p√©talo por especie](1102_distribution_files/figure-html/fig-distribution-species-1.png){#fig-distribution-species width=672}\n:::\n:::\n\n\n\n\nAh√° ü§î! Gracias a utilizar una est√©tica m√°s podemos ver que la distribuci√≥n no es bimodal, si no que son distribuciones de especies de flores distintas. En esencia, a√±adir una est√©tica m√°s puede ser visto como a√±adir una dimensi√≥n m√°s al gr√°fico.\n\n::: callout-note\nA partir de ahora vamos a ir a√±adiendo nuevas funciones y argumentos a nuestros gr√°ficos. No te preocupes si no entiendes todo a la primera, poco a poco iremos viendo c√≥mo se utilizan y para qu√© sirven. En este caso hemos a√±adido `theme_minimal()` que nos permite cambiar el tema base del gr√°fico. Existen una serie de temas predefinidos que empiezan por `theme_*()`.\n:::\n\n## Gr√°ficos de densidad\n\nLos gr√°ficos de densidad son una forma de visualizar la distribuci√≥n de una variable num√©rica. A diferencia de los histogramas, los gr√°ficos de densidad no agrupan los datos en intervalos, sino que muestran la estimaci√≥n de densidad kernel de los datos. Los gr√°ficos de densidad son √∫tiles para identificar la forma de la distribuci√≥n de los datos, ya que son una versi√≥n suavizada de los histogramas.\n\nPara crear un gr√°fico de densidad en `{ggplot2}`, utilizamos la funci√≥n `geom_density()`. B√°sicamente, se va a generar una l√≠nea que nos va a indicar la densidad de probabilidad de los datos. Como es una l√≠nea, tiene una serie de est√©ticas que podemos modificar a continuaci√≥n:\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 600\n\n## Load packages\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(glue)\nlibrary(shiny)\n\n## UI\nui <- page_sidebar(\n    sidebar = sidebar(\n        open  = \"open\",\n        width = 200,\n        selectInput(\n            inputId  = \"linetype_input\",\n            label    = \"Linetype\",\n            choices  = c(\"solid\", \"dashed\", \"dotted\",\n                         \"dotdash\", \"longdash\", \"twodash\"),\n            selected = \"solid\"\n        ),\n        sliderInput(\n            inputId = \"linewidth_input\",\n            label   = \"Linewidth\",\n            min     = 0,\n            max     = 4,\n            value   = 1,\n            step    = .5\n        ),\n        checkboxInput(\n            inputId = \"fill_input\",\n            label   = \"Rellenar?\",\n            value   = FALSE\n        )\n    ),\n    verbatimTextOutput(\"code\") |> card(),\n    plotOutput(\"plot\", width = 500) |> card()\n)\n\n## Server\nserver <- function(input, output, session) {\n    \n    output$code <- renderPrint({\n        \n        if (input$fill_input) {\n            glue(\n            'ggplot(iris, aes(x = Petal.Length)) +\n                geom_density(\n                    color     = \"darkred\",\n                    fill      = \"gray30\",\n                    linetype  = \"{input$linetype_input}\",\n                    linewidth = {input$linewidth_input}\n                ) +\n                labs(\n                    title = \"Distribuci√≥n de longitud del p√©talo\", \n                    x     = \"Longitud (mm)\", \n                    y     = \"Probabilidad (%)\"\n                ) +\n                theme_bw(base_size = 8)'\n            )\n        } else {\n            glue(\n            'ggplot(iris, aes(x = Petal.Length)) +\n                geom_density(\n                    color     = \"darkred\",\n                    linetype  = \"{input$linetype_input}\",\n                    linewidth = {input$linewidth_input}\n                ) +\n                labs(\n                    title = \"Distribuci√≥n de longitud del p√©talo\", \n                    x     = \"Longitud (mm)\", \n                    y     = \"Probabilidad (%)\"\n                ) +\n                theme_bw()'\n            )\n        }\n    })\n\n    ## Plot\n    output$plot <- renderPlot({\n        ggplot(iris, aes(x = Petal.Length)) +\n            geom_density(\n                color     = \"darkred\",\n                linetype  = input$linetype_input,\n                linewidth = input$linewidth_input,\n                fill      = if (input$fill_input) \"gray30\" else NA\n            ) +\n            labs(\n                title = \"Distribuci√≥n de longitud del p√©talo\", \n                x     = \"Longitud (mm)\", \n                y     = \"Probabilidad (%)\"\n            ) +\n            theme_bw(base_size = 8)\n    }, res = 96)\n}\n\n## Run app\nshinyApp(ui = ui, server = server)\n```\n\n### Ejercicio 1\n\nFinalmente, al igual que con los histogramas, podemos comparar la distribuci√≥n de la longitud del p√©talo entre las diferentes especies de flores del *dataset* `iris`. Te atreves a intentar a√±adir la parte del c√≥digo que falta? El resultado deber√≠a ser el indicado en la @fig-distribution-ej1:\n\n::: panel-tabset\n## Gr√°fico esperado\n\nIntenta replicar este gr√°fico en la pesta√±a \"Ejercicio\"\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Resultado esperado del ejercicio 1](1102_distribution_files/figure-html/fig-distribution-ej1-1.png){#fig-distribution-ej1 width=672}\n:::\n:::\n\n\n\n\n## Ejercicio\n\nEn total hay que a√±adir tres elementos:\n\n-   Transparencia (necesaria para poder ver la superposici√≥n de densidades)\n\n-   Eliminar color de contorno\n\n-   Crear un gr√°fico de densidad por especie dentro del mismo gr√°fico\n\n```{webr-r}\niris |> \n    ggplot(\n        aes(x = Petal.Length)\n    ) +\n    geom_density() +\n    labs(\n        title = \"Distribuci√≥n de longitud del p√©talo\",\n        x     = \"Longitud (mm)\", \n        y     = \"Probabilidad (%)\"\n    ) +\n    theme_bw()\n```\n\n## Soluci√≥n\n\nEl argumento `aes(fill = Species)` tambi√©n se puede introducir en la funci√≥n `ggplot()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris |> \n    ggplot(aes(x = Petal.Length)) +\n    geom_density(\n        aes(fill = Species),\n        color    = NA,\n        alpha    = .8\n    ) +\n    labs(\n        title = \"Distribuci√≥n de longitud del p√©talo\",\n        x     = \"Longitud (mm)\", \n        y     = \"Probabilidad (%)\"\n    ) +\n    theme_bw()\n```\n\n::: {.cell-output-display}\n![Resultado del ejercicio 1](1102_distribution_files/figure-html/fig-distribution-ej1-sol-1.png){#fig-distribution-ej1-sol width=672}\n:::\n:::\n\n\n\n:::\n\n### Ejercicio 2\n\nEn los siguientes ejercicios vamos a trabajar con los datos de inventario. Vamos a empezar cargando los datos, convertirlos a `tibble` y vamos a ver de nuevo su estructura:\n\n```{webr-r}\n## Url de los datos\nurl <- \"https://cidree.github.io/MG_datasets/inventario_prep.csv\"\ninventario_tbl <- read.csv(url) |> as_tibble()\n## Estructura datos\ninventario_tbl\n```\n\nEl ejercicio consiste en generar un histograma de la distribuci√≥n diam√©trica (en cent√≠metros), adem√°s generando un gr√°fico por especie. Utiliza el siguiente bloque de c√≥digo y practica todo lo que hemos visto hasta ahora:\n\n::: panel-tabset\n## Ejercicio 2\n\n```{webr-r}\n## Escribir c√≥digo aqu√≠\n\n```\n\n## Resultado\n\nEl siguiente c√≥digo es una de muchas opciones.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninventario_tbl |> \n    ggplot(\n        aes(x = dbh_mm / 10, fill = nombre_ifn)\n    ) +\n    geom_histogram(\n        bins  = 25, \n        color = \"snow\"\n    ) +\n    labs(\n        title = \"Distribuci√≥n diam√©trica por especie\",\n        x     = \"Di√°metro (cm)\", \n        y     = \"Frecuencia\",\n        fill  = \"Especie\"\n    ) +\n    theme_minimal()\n```\n\n::: {.cell-output-display}\n![Resultado del ejercicio 2](1102_distribution_files/figure-html/fig-distribution-ej2-1.png){#fig-distribution-ej2 width=672}\n:::\n:::\n\n\n\n:::\n\nEn la @fig-distribution-ej2 hemos a√±adido el argumento `fill` dentro de la funci√≥n `labs()`. Cuando utilizamos una est√©tica como color, fill, shape... dentro de `aes()`, podemos utilizar el nombre de esta est√©tica dentro de `labs()` para modificar el t√≠tulo de la leyenda.\n\n### Ejercicio 3\n\nGenerar un gr√°fico de densidad para la altura de los √°rboles por especie.\n\n::: panel-tabset\n## Ejercicio 3\n\n```{webr-r}\n## Escribir c√≥digo aqu√≠\n\n```\n\n## Resultado\n\nEl siguiente c√≥digo es una de muchas opciones.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninventario_tbl |> \n    ggplot(\n        aes(x = height_m, fill = nombre_ifn)\n    ) +\n    geom_density(\n        alpha = .7\n    ) +\n    labs(\n        title = \"Distribuci√≥n de alturas por especie\",\n        x     = \"Altura (m)\", \n        y     = \"Probabilidad (%)\",\n        fill  = \"Especie\"\n    ) +\n    theme_minimal()\n```\n\n::: {.cell-output-display}\n![Resultado del ejercicio 3](1102_distribution_files/figure-html/fig-distribution-ej3-1.png){#fig-distribution-ej3 width=672}\n:::\n:::\n\n\n\n:::\n\n### Extra - A√±adir l√≠neas\n\nAlgo com√∫n es a√±adir l√≠neas a los gr√°ficos que representen alg√∫n valor importante como la media o la mediana. En esta breve secci√≥n vamos a ver como a√±adir estas dos l√≠neas a un histograma.\n\nVamos a empezar con un histograma de la distribuci√≥n diam√©trica de *P. sylvestris*:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninventario_tbl |> \n    filter(nombre_ifn == \"Pinus sylvestris\") |> \n    ggplot(\n        aes(x = dbh_mm)\n    ) +\n    geom_histogram(\n        color = \"snow\",\n        fill  = \"#0073C2FF\"\n    ) +\n    theme_bw()\n```\n\n::: {.cell-output-display}\n![Distribuci√≥n diam√©trica de *Pinus sylvestris*](1102_distribution_files/figure-html/fig-distribution-ps-1.png){#fig-distribution-ps width=672}\n:::\n:::\n\n\n\n\nLa idea es a√±adir una **l√≠nea vertical** que nos se√±ale donde se encuentran la media y la mediana. Para ello, tenemos la funci√≥n `geom_vline()`. El argumento m√°s importante es:\n\n-   `xintercept`: valor en el eje x donde se va a situar la l√≠nea.\n\nEl resto de argumentos pueden consultarse en la documentaci√≥n de la funci√≥n, y ser√°n los comunes a geometr√≠as de l√≠nea: *color, linewidth, linetype...*\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Filtrar datos de Pinus sylvestris\n## Crear columna de di√°metro en cm\npsylvestris_tbl <- inventario_tbl |> \n    filter(nombre_ifn == \"Pinus sylvestris\") |> \n    mutate(\n        dbh_cm = dbh_mm / 10\n    )\n    \n## Gr√°fico\npsylvestris_tbl |> \n    ggplot(\n        aes(x = dbh_cm)\n    ) +\n    geom_histogram(\n        color = \"snow\",\n        fill  = \"#0073C2FF\",\n        alpha = .7  \n    ) +\n    geom_vline(\n        aes(xintercept = mean(psylvestris_tbl$dbh_cm, na.rm = TRUE)),\n        color = \"darkred\",\n        size  = 1\n    ) +\n    geom_vline(\n        xintercept = median(psylvestris_tbl$dbh_cm, na.rm = TRUE),\n        color      = \"darkorange\",\n        size       = 1\n    ) +\n    labs(\n        title = \"Distribuci√≥n diam√©trica de Pinus sylvestris\",\n        x     = \"Di√°metro (cm)\", \n        y     = \"Frecuencia\"\n    ) +\n    theme_bw()\n```\n\n::: {.cell-output-display}\n![Distribuci√≥n diam√©trica de *Pinus sylvestris* con l√≠neas](1102_distribution_files/figure-html/fig-distribution-ps-lines-1.png){#fig-distribution-ps-lines width=672}\n:::\n:::\n\n\n\n\nComo solamente utilizamos un valor que generamos con `mean()` y `median()`, no es necesario utilizar `aes()` en `geom_vline()`. Se muestran ambas opciones para mostrar que es posible utilizar cualquiera de las dos opciones.\n\n## Boxplot\n\nLos *boxplot* (gr√°ficos de cajas o bigotes) son una forma de visualizar la distribuci√≥n de una variable num√©rica. En un gr√°fico de cajas, se muestra un resumen de la distribuci√≥n de los datos, incluyendo la mediana, los cuartiles y los valores at√≠picos. Los gr√°ficos de cajas son √∫tiles para identificar la presencia de valores at√≠picos y la simetr√≠a de la distribuci√≥n.\n\n![Partes de un boxplot. Fuente: [R Graph Gallery](https://r-graph-gallery.com/boxplot.html){target=\"_blank\"}](images/boxplot.png){#fig-boxplot-explanation fig-align=\"center\"}\n\nAunque es un gr√°fico que nos da un resumen estad√≠stico muy bueno, es un gr√°fico que **nunca** se debe utilizar solo. Un boxplot nos est√° mostrando cinco valores principales: m√≠nimo, primer cuartil, mediana, tercer cuartil y m√°ximo. Sin embargo, no sabemos nada del resto de valores. F√≠jate en los siguientes boxplot:\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Boxplots con datos ficticios con la misma forma](1102_distribution_files/figure-html/fig-boxplot-ex-1.png){#fig-boxplot-ex width=672}\n:::\n:::\n\n\n\n\nAmbos gr√°ficos tienen exactamente la misma forma, pero como puedes ver en los puntos, los datos son muy distintos. Es por ello que se suelen utilizar variantes del *boxplot* o el *boxplot* combinado con otras geometr√≠as como el *violin plot*.\n\nUna vez vista esta debilidad de los *boxplot*, vamos a generar uno para la distribuci√≥n de la longitud de los p√©talos del *dataset* de iris. En este caso, va a ser el primer gr√°fico de distribuci√≥n donde utilicemos ambas est√©ticas de los ejes `x` e `y`.\n\nLa funci√≥n `geom_boxplot()` tiene un mont√≥n de argumentos que podemos modificar. Los *outliers* se representan como puntos, y por ende, podemos modificar todo aquello relacionado con ellos con argumentos que empiezan por `outlier.*`. Por ejemplo, `outlier.shape`, `outlier.size`, `outlier.color`...\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_boxplot <- iris |> \n    ggplot(\n        aes(x = Species, y = Petal.Length)\n    ) +\n    geom_boxplot(\n        fill          = \"orangered\",\n        alpha         = .4,\n        outlier.shape = 21,\n        outlier.size  = 3,\n        outlier.color = \"black\",\n        varwidth      = TRUE\n    ) +\n    labs(\n        title = \"Distribuci√≥n de la longitud del p√©talo por especie\",\n        x     = \"Especie\", \n        y     = \"Longitud (mm)\"\n    ) +\n    theme_minimal()\n    \nbase_boxplot\n```\n\n::: {.cell-output-display}\n![Boxplot de la longitud del p√©talo](1102_distribution_files/figure-html/fig-boxplot-petal-1.png){#fig-boxplot-petal width=672}\n:::\n:::\n\n\n\n\nHemos guardo el gr√°fico en un objeto llamado `base_boxplot` para poder a√±adir m√°s elementos en la siguiente secci√≥n.\n\n### Boxplot + Jitter\n\nPara a√±adir la distribuci√≥n de los datos en un boxplot, podemos utilizar la funci√≥n `geom_point()`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_boxplot +\n    geom_point()\n```\n\n::: {.cell-output-display}\n![Boxplot de la longitud del p√©talo con geom_point()](1102_distribution_files/figure-html/fig-boxplot-petal-point-1.png){#fig-boxplot-petal-point width=672}\n:::\n:::\n\n\n\n\nSin embargo, como puedes ver, los puntos est√°n superpuestos. Para evitar esto, podemos utilizar la funci√≥n `position_jitter()` dentro del argumento `position` que nos permite a√±adir un poco de ruido a los puntos para que no se superpongan. Esto significa que los puntos tendr√°n un determinando porcentaje (0-1) de variaci√≥n en el eje `x` con el argumento `width` y en el eje `y` con el argumento `height`. Utiliza la siguiente herramienta para ver como funciona:\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 600\n\n## Load packages\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(glue)\nlibrary(shiny)\n\n## UI\nui <- page_sidebar(\n    sidebar = sidebar(\n        open = \"open\",\n        width = 200,\n        sliderInput(\"width_j\", \"Width\", min = 0, max = 1, value = .5, step = .1),\n        sliderInput(\"height_j\", \"Height\", min = 0, max = 1, value = .5, step = .1)\n    ),\n    verbatimTextOutput(\"code\") |> card(),\n    plotOutput(\"plot\", width = 500) |> card()\n)\n\n## Server\nserver <- function(input, output, session) {\n    \n    output$code <- renderPrint({\n        glue(\n            '\n            base_boxplot +\n                geom_point(\n                    position = position_jitter(\n                        width  = {input$width_j},\n                        height = {input$height_j}\n                    ),\n                    alpha    = .7\n                )'\n            )\n    })\n\n    ## Plot\n    output$plot <- renderPlot({\n        ggplot(iris, aes(x = Species, y = Petal.Length)) +\n            geom_boxplot(\n                fill          = \"orangered\",\n                alpha         = .4,\n                outlier.shape = 21,\n                outlier.size  = 3,\n                outlier.color = \"black\",\n                varwidth      = TRUE\n            ) +\n            labs(\n                title = \"Distribuci√≥n de la longitud del p√©talo por especie\",\n                x     = \"Especie\", \n                y     = \"Longitud (mm)\"\n            ) +\n            theme_minimal() +\n                        geom_point(\n                            position = position_jitter(\n                                width  = {input$width_j},\n                                height = {input$height_j}\n                            ),\n                            alpha    = .7\n                        ) +\n                    theme_gray(base_size = 8)\n    }, res = 96)\n}\n\n## Run app\nshinyApp(ui = ui, server = server)\n```\n\nSi ambos son igual a 0, significa que no se a√±ade ruido. si aumentamos `width`, veremos que los datos se mantienen en sus valores originales seg√∫n la variable de longitud del p√©talo, pero se mueven aleatoriamente a lo largo del eje `x`. De este modo podemos ver mejor la distribuci√≥n. No obstante, esto es recomendable solamente en variables categ√≥ricas para que los puntos no est√©n unos encima de otros. En variables num√©ricas no tiene sentido ya que estamos modificando los datos. Es decir, en este ejemplo `height` debe ser igual a 0.\n\n::: callout-note\nSi utilizamos un valor igual o superior a 0.5 los puntos de distintas categor√≠as se superpondr√°n.\n:::\n\nComo esta geometr√≠a es muy com√∫n, `{ggplot2}` tiene la funci√≥n `geom_jitter()` que es un atajo para `geom_point(position = position_jitter())`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_boxplot +\n    geom_jitter(height = 0, width = .2)\n```\n\n::: {.cell-output-display}\n![Boxplot de la longitud del p√©talo con geom_jitter()](1102_distribution_files/figure-html/fig-boxplot-petal-jitter-1.png){#fig-boxplot-petal-jitter width=672}\n:::\n:::\n\n\n\n\n### Ejercicio 4\n\nGenerar un *boxplot* de la distribuci√≥n diam√©trica por especie. Adem√°s, a√±adir la distribuci√≥n de los puntos. Para practicar, utiliza la documentaci√≥n de `geom_boxplot()` para modificar distintos argumentos.\n\n::: panel-tabset\n## Ejercicio 4\n\n```{webr-r}\n## Escribir c√≥digo aqu√≠\n\n```\n\n## Resultado\n\nEl siguiente c√≥digo es una de muchas opciones.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Crear boxplot\ninventario_tbl |> \n    ggplot(\n        aes(x = nombre_ifn, y = dbh_mm / 10)\n    ) +\n    geom_boxplot(\n        fill          = \"#82BE1F\",\n        outlier.shape = 21,\n        outlier.size  = 3,\n        outlier.fill  = \"#E121DB\",\n        varwidth      = TRUE,\n        width         = .5\n    ) +\n    geom_jitter(\n        color = \"#7D9E69\",\n        height = 0,\n        width  = .4,\n        alpha  = .3\n    ) +\n    labs(\n        title = \"Distribuci√≥n diam√©trica por especie\",\n        x     = \"Especie\", \n        y     = \"Di√°metro (cm)\"\n    ) +\n    theme_minimal()\n```\n\n::: {.cell-output-display}\n![Resultado del ejercicio 4](1102_distribution_files/figure-html/fig-boxplot-ej4-1.png){#fig-boxplot-ej4 width=672}\n:::\n:::\n\n\n\n:::\n\n### Extra - A√±adir media\n\nTambi√©n es posible a√±adir la localizaci√≥n de la media mediante un punto en un *boxplot*. Para ello, utilizamos la funci√≥n `geom_point()`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_boxplot +\n    geom_point()\n```\n\n::: {.cell-output-display}\n![](1102_distribution_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\n\nBueeeno üòÖ... Recuerdas cu√°ndo habl√°bamos de las transformaciones estad√≠sticas en @sec-components? Pues por defecto `geom_point()` utiliza `stat = \"identity\"`, que quer√≠a decir que no se aplica ninguna transformaci√≥n, y por lo tanto $f(x) = x$. Ser√° `{ggplot2}` tan m√°gico que nos dejar√° decir que realice una transformaci√≥n estad√≠stica en la que convierta los puntos a la media? S√≠, pero debemos utilizar la transformaci√≥n estad√≠stica `summary`, y elegir una funci√≥n de resumen con el argumento `fun`. En realidad, podemos a√±adir varias funciones que puedes probar aqu√≠:\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 600\n\n## Load packages\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(glue)\nlibrary(shiny)\n\n## UI\nui <- page_sidebar(\n    sidebar = sidebar(\n        open = \"open\",\n        width = 200,\n        selectInput(\n            inputId = \"fun_input\", \n            label   = \"Funci√≥n\", \n            choices = c(\"min\", \"max\", \"mean\", \"median\", \"quantile\")\n        )\n    ),\n    verbatimTextOutput(\"code\") |> card(),\n    plotOutput(\"plot\", width = 500) |> card()\n)\n\n## Server\nserver <- function(input, output, session) {\n    \n    output$code <- renderPrint({\n        glue(\n            '\n            base_boxplot +\n                geom_point(\n                    stat  = \"summary\",\n                    fun   = {input$fun_input},\n                    shape = 4,\n                    size  = 3,\n                    color = \"red\"\n                )'\n            )\n    })\n\n    ## Plot\n    output$plot <- renderPlot({\n        ggplot(iris, aes(x = Species, y = Petal.Length)) +\n            geom_boxplot(\n                fill          = \"orangered\",\n                alpha         = .4,\n                outlier.shape = 21,\n                outlier.size  = 3,\n                outlier.color = \"black\",\n                varwidth      = TRUE\n            ) +\n            labs(\n                title = \"Distribuci√≥n de la longitud del p√©talo por especie\",\n                x     = \"Especie\", \n                y     = \"Longitud (mm)\"\n            ) +\n            theme_minimal() +\n            geom_point(\n                stat  = \"summary\",\n                fun   = {input$fun_input},\n                shape = 4,\n                size  = 3,\n                color = \"red\"\n            ) +\n            theme_gray(base_size = 8)\n    }, res = 96)\n}\n\n## Run app\nshinyApp(ui = ui, server = server)\n```\n\nCualquier funci√≥n que se pueda aplicar a un vector num√©rico, se puede a√±adir dentro del argumento `fun`, y esto incluye funciones personalizadas.\n\n::: callout-tip\nSi quieres ver las opciones del argumento `shape`, puedes consultar la documentaci√≥n de la funci√≥n `points()`.\n\n![Opciones de puntos para el argumento \\`shape\\`](images/point-shape.png){#fig-point-shapes fig-align=\"center\"}\n:::\n\n## Violin plot\n\nEl *violin plot* es una forma de visualizar la distribuci√≥n de una variable num√©rica. A diferencia del *boxplot*, el *violin plot* muestra la distribuci√≥n de los datos de forma m√°s detallada, de forma que no es necesario a√±adir una capa de puntos **jitter** para tener una idea de la distribuci√≥n de los datos.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_violin <- iris |> \n    ggplot(\n        aes(x = Species, y = Petal.Length)\n    ) +\n    geom_violin(\n        fill  = \"#0073C2FF\",\n        color = \"white\"\n    ) +\n    labs(\n        title = \"Distribuci√≥n de la longitud del p√©talo por especie\",\n        x     = \"Especie\", \n        y     = \"Longitud (mm)\"\n    ) +\n    theme_minimal()\n  \nbase_violin\n```\n\n::: {.cell-output-display}\n![Violin plot de la longitud del p√©talo](1102_distribution_files/figure-html/fig-violin-petal-1.png){#fig-violin-petal width=672}\n:::\n:::\n\n\n\n\nEn la @fig-violin-petal vemos que los gr√°ficos son m√°s o menos anchos. Cuanto m√°s anchos, m√°s datos hay en esa zona. Para tener una idea de lo que significa, podemos a√±adir una capa de puntos y as√≠ entenderlo mejor:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_violin +\n  geom_jitter(\n      alpha  = .5,\n      height = 0\n  ) \n```\n\n::: {.cell-output-display}\n![Violin plot de la longitud del p√©talo con `geom_jitter()`](1102_distribution_files/figure-html/fig-violin-petal-jitter-1.png){#fig-violin-petal-jitter width=672}\n:::\n:::\n\n\n\n\nComo puedes ver, los puntos se distribuyen en funci√≥n de la anchura del *violin plot*. Si la anchura es mayor, significa que hay m√°s datos en esa zona.\n\nOpciones interesantes para modificar el *violin plot* son:\n\n-   `trim`: si es `FALSE`, el *violin plot* se extender√° hasta los valores extremos de los datos. Si es `TRUE` (por defecto), se extender√° hasta el valor m√°s extremo que no sea un valor at√≠pico.\n\n-   `scale`: si es `area` (por defecto), el √°rea de cada *violin* es proporcional al n√∫mero de observaciones. Si es `count`, el ancho de cada *violin* es proporcional al n√∫mero de observaciones.\n\n-   `draw_quantiles`: si es `TRUE`, se dibujar√°n los cuantiles del 25%, 50% y 75% en el *violin plot*.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris |> \n    ggplot(\n        aes(x = Species, y = Petal.Length)\n    ) +\n    geom_violin(\n        fill  = \"#0073C2FF\",\n        color = \"white\",\n        trim  = TRUE,\n        scale = \"area\",\n        draw_quantiles = c(.25, .5, .75),\n    ) +\n    labs(\n        title = \"Distribuci√≥n de la longitud del p√©talo por especie\",\n        x     = \"Especie\", \n        y     = \"Longitud (mm)\"\n    ) +\n    theme_minimal()\n```\n\n::: {.cell-output-display}\n![Violin plot de la longitud del p√©talo con opciones](1102_distribution_files/figure-html/fig-violin-petal-options-1.png){#fig-violin-petal-options width=672}\n:::\n:::\n\n\n\n\n### Ejercicio 5 {#sec-ej5}\n\nGenerar un *violin plot* de la distribuci√≥n diam√©trica por especie de `inventario_tbl`. Adem√°s, a√±adir una capa de puntos para ver la distribuci√≥n de los datos. Visualizar la diferencia entre `scale = \"area\"` y `scale = \"count\"` y quedarse con el que te parezca m√°s adecuado (en la pesta√±a \"Resultado\" se explica cu√°l es la mejor opci√≥n).\n\nEl resultado de este ejercicio lo utilizaremos en @sec-ej6, as√≠ que guarda el *violin plot* en un objeto llamado `violin_ej5_gg`.\n\n::: panel-tabset\n## Ejercicio 5\n\n```{webr-r}\n## Escribir c√≥digo aqu√≠\n```\n\n## Resultado\n\nEl siguiente c√≥digo es una de muchas opciones.\n\nCon `scale = \"count\"`, vemos que de *P. sylvestris* tenemos muchos m√°s datos. Si utilizamos `scale = \"area`, esto no lo sabemos. Por lo tanto, es mejor utilizar `scale = \"count\"`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Crear violin plot\nviolin_ej5_gg <- inventario_tbl |> \n    ggplot(\n        aes(x = nombre_ifn, y = dbh_mm / 10)\n    ) +\n    geom_violin(\n        fill  = \"#82BE1F\",\n        color = \"transparent\",\n        trim  = TRUE,\n        scale = \"count\"\n    ) +\n    labs(\n        title = \"Distribuci√≥n diam√©trica por especie\",\n        x     = \"Especie\", \n        y     = \"Di√°metro (cm)\"\n    ) +\n    theme_bw()\n## Imprimir\nviolin_ej5_gg\n```\n\n::: {.cell-output-display}\n![Resultado del ejercicio 5](1102_distribution_files/figure-html/fig-violin-ej5-1.png){#fig-violin-ej5 width=672}\n:::\n:::\n\n\n\n:::\n\n### Ejercicio 6 {#sec-ej6}\n\nEn la @sec-ej5 hemos generado un diam√©trica por especie que guardamos como `violin_ej5_gg`. A este gr√°fico, a√±adir un *boxplot* y un punto que represente la media de la distribuci√≥n.\n\n::: panel-tabset\n## Ejercicio 6\n\n```{webr-r}\n## Escribir c√≥digo aqu√≠\n```\n\n## Resultado\n\nEl siguiente c√≥digo es una de muchas opciones.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nviolin_ej5_gg +\n    geom_boxplot(\n        fill     = \"transparent\",\n        outliers = FALSE,\n        varwidth = TRUE,\n        width    = .2\n    ) +\n    geom_point(\n        stat  = \"summary\",\n        fun   = \"mean\",\n        shape = 19,\n        size  = 3,\n        color = \"red\"\n    )\n```\n\n::: {.cell-output-display}\n![Resultado del ejercicio 6](1102_distribution_files/figure-html/fig-violin-ej6-1.png){#fig-violin-ej6 width=672}\n:::\n:::\n\n\n\n:::\n\nEnhorabuena! Has llegado al final de la secci√≥n de distribuciones. En la siguiente secci√≥n vamos a ver c√≥mo podemos comparar distribuciones entre diferentes grupos.\n\n## Resumen\n\nEn esta secci√≥n hemos aprendido a visualizar la distribuci√≥n de una variable num√©rica utilizando distintos tipos de gr√°ficos. Hemos visto c√≥mo crear histogramas, gr√°ficos de densidad, *boxplots* y *violin plots*. Adem√°s, hemos aprendido a a√±adir capas de puntos a los gr√°ficos para ver la distribuci√≥n de los datos, res√∫menes estad√≠sticos como la media y a modificar distintos argumentos de las geometr√≠as.\n",
    "supporting": [
      "1102_distribution_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}