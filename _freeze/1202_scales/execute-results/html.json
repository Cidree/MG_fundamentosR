{
  "hash": "94963166f30147b92cfab649e53363c5",
  "result": {
    "engine": "knitr",
    "markdown": "---\nexecute: \n  warning: false\neditor_options: \n  chunk_output_type: console\nfilters: \n    - webr\nwebr:\n    packages: [\"dplyr\", \"ggplot2\"]\nbibliography: references.bib\n---\n\n\n\n\n# Scales {#sec-scales}\n\nLas escalas son una parte fundamental de la visualización de datos. Son las encargadas de mapear los valores de los datos a los elementos visuales de la gráfica. Podemos dividirlas en las siguientes clases:\n\n-   **Escalas continuas**: se utilizan para modificar la apariencia de los elementos visuales en función de valores numéricos.\n\n-   **Escalas discretas**: se utilizan para modificar la apariencia de los elementos visuales en función de valores categóricos.\n\n-   **Escalas en intervalos**: se utilizan para modificar la apariencia de los elementos visuales en función de valores numéricos que se encuentran en un intervalo.\n\nAdemás, se puede subdividir las escalas en función de la estética que modifican:\n\n-   **Escalas de posición y ejes**: controlar la posición de los elementos visuales además de sus ejes. En esta categoría tenemos la estética `x` e `y`.\n\n-   **Escalas de colores**: controlan el color externo y color de relleno de los elementos visuales y sus leyendas. En esta categoría tenemos las estéticas `color` y `fill`.\n\n-   **Otras escalas y leyendas**: controlar el aspecto de los elementos visuales y sus respectivas leyendas. En esta categoría tenemos las estéticas `alpha`, `linetype`, `linewidth`, `shape` y `size`.\n\nEn este capítulo vamos a trabajar con tres *datasets*:\n\n-   `iris`: *dataset* donde se han medido la longitud y anchura de pétalos y sépalos de 150 flores, además de la especie a la que pertenecen (ver [Tipos de visualización](#sec-visualization-types){target=\"_blank\"}).\n\n-   `gapminder`: *dataset* con la evolución temporal del desarrollo económico, población y esperanza de vida de los países del mundo (ver [Tipos de visualización](#sec-visualization-types){target=\"_blank\"}). Filtraremos solamente los datos del 2002.\n\n-   `inventario`: *dataset* con datos de inventario de 27 parcelas en los que se ha medido el DBH, altura y especie (ver @sec-vis-data).\n\nPara comenzar, vamos a cargar los paquetes necesarios y a leer los datos que utilizaremos en este capítulo.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Paquetes internos\nlibrary(RColorBrewer)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gapminder)\nlibrary(geomtextpath)\nlibrary(tidyverse)\n```\n:::\n\n\n\n\n## Estructura de las escalas\n\nLas escalas en `ggplot2` son funciones que tienen una estructura de generalmente tres palabras separadas por un guión bajo. Estas palabras son:\n\n-   **scale**: es la primera palabra de la función siempre.\n\n-   **Nombre de la estética**: es la segunda palabra de la función y se refiere a la estética que se quiere modificar (`x`, `y`, `color`, `fill`, `alpha`, `linetype`, `linewidth`, `shape` o `size`).\n\n-   **Tipo de escala**: es la tercera palabra de la función y se refiere al tipo de escala que se quiere aplicar (`continuous`, `discrete`, `manual`, `identity`, `log`, ...).\n\nEn las siguientes sección veremos algunas de las más importantes.\n\n## Escalas de posición\n\nLas escalas de posición se utilizan para mapear los valores de los datos a las posiciones de los elementos visuales de la gráfica. Todos los gráficos tienen dos escalas de posición que son la estética `x` y la estética `y`. Todos los gráficos traen una escala por defecto que depende de si la variable es categórica o numérica:\n\n-   `scale_x_continuous()` y : escala de posición para variables numéricas en el eje x.\n\n-   `scale_y_continuous()`: escala de posición para variables numéricas en el eje y.\n\n-   `scale_x_discrete()`: escala de posición para variables categóricas en el eje x.\n\n-   `scale_y_discrete()`: escala de posición para variables categóricas en el eje y.\n\n::: callout-note\nExiste alguna excepción como el formato fecha que utiliza `scale_*_date()` o el formato fecha-tiempo que utiliza `scale_*_datetime()`.\n:::\n\nVamos a empezar con un ejemplo sencillo utilizando el *dataset* `iris`.\n\n::: panel-tabset\n## Sin escalas\n\nEn este primer ejemplo, generamos un gráfico de la distribución de la anchura del sépalo según la especie. Tenemos que añadir una semilla para que el proceso aleatorio de `geom_jitter()` sea el mismo en ambos ejemplos.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\nggplot(iris, aes(x = Species, y = Sepal.Width)) +\n    geom_jitter(height = 0, width = .2)\n```\n\n::: {.cell-output-display}\n![Distribución de la anchura del pétalo por especie de Iris](1202_scales_files/figure-html/fig-jitter-no-scales-1.png){#fig-jitter-no-scales width=672}\n:::\n:::\n\n\n\n\n## Con escalas\n\nSi añadimos las escalas que supuestamente son las que vienen por defecto, no debería cambiar nada en nuestro gráfico:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\nggplot(iris, aes(x = Species, y = Sepal.Width)) +\n    geom_jitter(height = 0, width = .2) +\n    scale_x_discrete() +\n    scale_y_continuous()\n```\n\n::: {.cell-output-display}\n![Distribución de la anchura del pétalo por especie de Iris](1202_scales_files/figure-html/fig-jitter-scales-1.png){#fig-jitter-scales width=672}\n:::\n:::\n\n\n\n:::\n\nPues bien, hasta aquí nada nuevo. Vamos a empezar a ver finalmente qué podemos hacer con las escalas de posición.\n\n### Escalas de posición continuas\n\nPara trabajar sobre escalas de posición continuas vamos a partir de este ejemplo que ya hemos trabajado en secciones anteriores del dataset de `gapminder`. Vamos a empezar preparando los datos:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder_tbl <- gapminder |> \n    filter(continent != \"Africa\") |>\n    mutate(year = as_date(\n        paste0(year, \"-01-01\")\n    ))\n```\n:::\n\n\n\n\nComo veis, estamos convirtiendo la columna `year` a tipo de dato `Date` en lugar de `numeric`. En un rato veréis por qué.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_plot <- gapminder_tbl |> \n    ggplot(\n        aes(x = year, y = gdpPercap, color = country, group = country)\n    ) +\n    geom_line(color = \"grey80\") +\n    geom_textpath(\n        aes(x = year, y = gdpPercap, label = country),\n        data  = gapminder_tbl |> filter(country %in% c(\"Kuwait\", \"Nicaragua\", \"Haiti\")),\n        color = \"#BC3908\",\n        lwd   = 1,\n        size  = 3\n    ) +\n    labs(\n        x     = NULL,\n        y     = \"PIB per cápita\",\n        color = NULL,\n        title = \"La mayoría de países aumentaron su PIB per cápita entre 1952 y 2007. \\nKuwait, Nicaragua y Haiti no\"\n    ) +\n    theme_minimal()\n\nbase_plot\n```\n\n::: {.cell-output-display}\n![Spaguetti plot mostrando la evolución del PIB per cápita de los países del mundo](1202_scales_files/figure-html/fig-spaguetti-scales-1.png){#fig-spaguetti-scales width=672}\n:::\n:::\n\n\n\n\nVamos a ver qué podemos modificar:\n\n::: panel-tabset\n## Intervalos\n\nPodemos indicar un vector de valores para especificar los valores que queremos ver en los ejes. Además, con name también podemos modificar el nombre de este eje (al igual que en la función `labs()`).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_plot +\n    scale_y_continuous(\n        name   = \"PIB per cápita ($)\",\n        breaks = seq(0, 100000, 20000)\n    )\n```\n\n::: {.cell-output-display}\n![](1202_scales_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n\nFíjate que al superar los 5 dígitos la notación es decimal. Podemos cambiar este comportamiento del siguiente modo:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(scipen = 999)\nbase_plot +\n    scale_y_continuous(\n        name   = \"PIB per cápita ($)\",\n        breaks = seq(0, 100000, 20000)\n    )\n```\n\n::: {.cell-output-display}\n![](1202_scales_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\n\n## Número de intervalos\n\nEn lugar de indicar los intervalos que queremos, podemos indicar un número de intervalos para que la función los calcule óptimamente. Vamos a indicar un total de 10 intervalos:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_plot +\n    scale_y_continuous(\n        name     = \"PIB per cápita ($)\",\n        n.breaks = 10\n    )\n```\n\n::: {.cell-output-display}\n![](1202_scales_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\n\n## Intervalos menores\n\nSi te fijas, en la grilla del gráfico tenemos unas líneas más gruesas en las etiquetas y otras más finas entre las etiquetas. Estás líneas más finas son los intervalos menores. Para ver lo que significa esto, vamos a crear un `minor break` cada \\$2000.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_plot +\n    scale_y_continuous(\n        name         = \"PIB per cápita ($)\",\n        n.breaks     = 10,\n        minor_breaks = seq(0, 110000, 2000)\n    )\n```\n\n::: {.cell-output-display}\n![](1202_scales_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\n\n## Etiquetas ejes\n\nLas etiquetas son los valores que muestran los intervalos que creamos con `breaks` o `n_breaks`. Podemos poner lo que queramos. Por ver un ejemplo obvio de lo que se puede hacer:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_plot +\n    scale_y_continuous(\n        name   = \"PIB per cápita ($)\",\n        breaks = seq(0, 100000, 20000),\n        labels = c(\"Cero\", \"Primera\", \"Segunda\", \"Tercera\", \"Cuarta\", \"Quinta\")\n    )\n```\n\n::: {.cell-output-display}\n![](1202_scales_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n\nAhora vamos a ver un ejemplo mucho más útil utilizando el paquete `scales`. Este paquete nos permite añadir símbolos, separar unidades, etc. En lugar de tener valores como 100000, vamos a modificarlos para que muestren \\$100,000. Para ello utilizamos la función `label_dollar()` que por defecto modifica el comportamiento al que nosotros queremos.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_plot +\n    scale_y_continuous(\n        breaks = seq(0, 100000, 20000),\n        labels = scales::label_dollar()\n    )\n```\n\n::: {.cell-output-display}\n![](1202_scales_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n\n\nComo en España es común separar decimales por comas y los miles por puntos, podemos modificar este comportamiento así:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_plot +\n    scale_y_continuous(\n        breaks = seq(0, 100000, 20000),\n        labels = scales::label_dollar(\n            big.mark     = \".\",\n            decimal.mark = \",\"\n        )\n    )\n```\n\n::: {.cell-output-display}\n![](1202_scales_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\n\nPuede parecer una sintaxis extraña. Este tipo de funciones se llaman *function factories* y es un tema avanzado y que queda fuera de los objetivos de este curso. En [este enlace](https://adv-r.hadley.nz/function-factories.html) se puede ver una lectura adicional sobre este tipo de funciones.\n\n## Límites ejes\n\nFinalmente, vamos a ver que podemos hacer zoom a un área del gráfico. Vamos a ver el área de \\$0 hasta \\$20,000.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_plot +\n    scale_y_continuous(\n        name   = \"PIB per cápita ($)\",\n        limits = c(0, 20000)\n    )\n```\n\n::: {.cell-output-display}\n![](1202_scales_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\n:::\n\nEste sería el funcionamiento básico de las funciones `scale_*_continuous()`. No obstante, podemos modificar la función utilizando una aceptable por variables continuas:\n\n::: panel-tabset\n## Transformaciones\n\nLas escalas normales van a mapear los valores originales de nuestros datos. Sin embargo, podemos aplicar transformaciones directas a las escalas como por ejemplo la transformación logarítmica:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_plot +\n    scale_y_log10()\n```\n\n::: {.cell-output-display}\n![](1202_scales_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\n\nDel mismo modo, podemos aplicar los mismos argumentos:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_plot +\n    scale_y_log10(\n        name   = \"PIB (escala logarítmica)\",\n        breaks = seq(0, 100000, 20000),\n        labels = scales::label_dollar(\n            big.mark     = \".\",\n            decimal.mark = \",\"\n        )\n    )\n```\n\n::: {.cell-output-display}\n![](1202_scales_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n\n\nComo utilizamos logaritmos nos aparecen los decimales que son siempre dos ceros. Podemos eliminarlos:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_plot +\n    scale_y_log10(\n        name   = \"PIB (escala logarítmica)\",\n        breaks = seq(0, 100000, 20000),\n        labels = scales::label_dollar(\n            big.mark     = \".\",\n            decimal.mark = \",\",\n            accuracy     = 1\n        )\n    )\n```\n\n::: {.cell-output-display}\n![](1202_scales_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\n\n## Fechas\n\nPara variables de tipo fecha tenemos una serie de funciones que nos ayudan a mostrar las etiquetas. Sin embargo, tenemos que convertir el tipo de dato a fecha, algo que hemos hecho previamente cuando creamos `gapminder_tbl`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_plot +\n    scale_x_date()\n```\n\n::: {.cell-output-display}\n![](1202_scales_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n\n\nEn verdad, cuando la variable es de tipo fecha se aplica esta escala por defecto. Vamos a modificar sus etiquetas para ver los años de cinco en cinco. Podemos utilizar el argumento `date_breaks` que permite una sintaxis muy flexible y amigable:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_plot +\n    scale_x_date(\n        date_breaks = \"5 years\"\n    )\n```\n\n::: {.cell-output-display}\n![](1202_scales_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n\n\nVaya infortunio. Esta función nos añade los meses y los años... Pero no os preocupéis!! Paquete `scales` al rescate:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_plot +\n    scale_x_date(\n        date_breaks = \"5 years\",\n        labels      = scales::label_date(format = \"%Y\")\n    )\n```\n\n::: {.cell-output-display}\n![](1202_scales_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n\n\nEl argumento `format` nos permite escribir el formato de fecha siguiendo unos estándares. Busca la ayuda de la función `strptime()` para ver las opciones disponibles. Las más comunes puedes verlas [aquí](https://ggplot2-book.org/scales-position#sec-date-labels). Existe una opción que no necesita del paquete `scales`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_plot +\n    scale_x_date(\n        date_breaks = \"5 years\",\n        date_labels = \"%Y\"\n    )\n```\n\n::: {.cell-output-display}\n![](1202_scales_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n\n:::\n\nPues esto sería todo por esta parte de la sección. Como ves, es muy sencillo trabajar con las escalas gracias a la gramática de gráficos adaptada a `{ggplot2}`.\n\n### Escalas de posición discretas\n\nVamos a ver ahora las escalas que mapean una variable de tipo categórico. La verdad es que aquí no vamos a introducir nada nuevo. La única diferencia con las anteriores es que utilizamos una función distinta y los argumentos que tenemos disponibles. En este caso no tiene sentido crear intervalos en la escala, ya que una variable categórica tiene los valores fijos. Lo que podemos es modificar las etiquetas y también la posición de la escala (esto lo podemos hacer también con las funciones anteriores, pero quería añadir algo nuevo en esta sección).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\nggplot(iris, aes(x = Species, y = Sepal.Width)) +\n    geom_jitter(height = 0, width = .2) +\n    scale_x_discrete(\n        name     = NULL,\n        labels   = c(\"I. setosa\", \"I. versicolor\", \"I. virginica\"),\n        position = \"top\"\n    )\n```\n\n::: {.cell-output-display}\n![](1202_scales_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n\n\nFinalmente, puedes ver que todas las funciones tienen un argumento denominado `guide`. Esto lo veremos más adelante.\n\n## Escalas de colores\n\nLas escalas de colores modifican el color de las líneas (`color`) y el color de relleno (`fill`). Las escalas de posición actúan sobre los ejes `x` e `y`, mientras que las que veremos en esta sección actúan sobre los colores de las geometrías generando una leyenda. Por defecto, se aplican las siguientes:\n\n-   `scale_color_continuous()` / `scale_fill_continuous()`: para variables continuas.\n\n-   `scale_color_discrete()` / `scale_fill_discrete()`: para variables categóricas.\n\n### Variables continuas\n\nVamos a empezar viendo como actúan las escalas por defecto en variables continuas:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscatter_base <- gapminder |> \n    filter(year == 2007) |> \n    ggplot(\n        aes(x = gdpPercap, y = lifeExp, color = pop)\n    ) +\n    geom_point() +\n    labs(\n        x = \"PIB per cápita\",\n        y = \"Esperanza de vida\"\n    ) +\n    theme_minimal()\n\nscatter_base\n```\n\n::: {.cell-output-display}\n![Scatter plot del PIB per cápita, esperanza de vida y población de los países del mundo](1202_scales_files/figure-html/fig-gapminder-scales-scatter-1.png){#fig-gapminder-scales-scatter width=672}\n:::\n:::\n\n\n\n\nLa función `scale_color_continuous()` nos permite modificar la escala de colores con unos argumentos similares a los que vimos en las escalas de posición. Vamos a ver un ejemplo:\n\n::: panel-tabset\n## Intervalos\n\nLos intervalos los definimos de nuevo con `breaks` o `n.breaks`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscatter_base +\n    scale_color_continuous(\n        name   = \"Población\",\n        breaks = seq(0, 1e9, 2e8)\n    )\n```\n\n::: {.cell-output-display}\n![](1202_scales_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nscatter_base +\n    scale_color_continuous(\n        name     = \"Población\",\n        n.breaks = 3\n    )\n```\n\n::: {.cell-output-display}\n![](1202_scales_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\n\n\n## Etiquetas ejes\n\nLas etiquetas las definimos con `labels`. Vamos a ver un ejemplo con el paquete `scales`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscatter_base +\n    scale_color_continuous(\n        name   = \"Población\",\n        labels = scales::label_number(\n            big.mark     = \".\",\n            decimal.mark = \",\"\n        )\n    )\n```\n\n::: {.cell-output-display}\n![](1202_scales_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\n\n\n## Tipo de paleta\n\nPodemos modificar el tipo de paleta de colores con el argumento `type`. Este es un argumento que las escalas de posición no tienen.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscatter_base +\n    scale_color_continuous(\n        name = \"Población\",\n        type = \"viridis\"\n    )\n```\n\n::: {.cell-output-display}\n![](1202_scales_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\n\n:::\n\nEn la última pestaña hemos visto como utilizar una paleta de colores mediante el argumento `type`. Sin embargo, algunas paletas comunes traen sus propias funciones del tipo `scale_color_*()` con una mayor flexibilidad.\n\n#### Paletas predefinidas\n\nLas escalas `viridis` [@garnier2018viridis] son una familia de paletas de colores que seguramente has visto en muchos gráficos. Estas son unas paletas con un gran diseño y que además son amigables con problemas de visión como el daltonismo. En la siguiente aplicación puedes ver las escalas `viridis` modificando el argumento `option` de la función `scale_color_viridis_c()`.\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 600\n\n## Load packages\nlibrary(bslib)\nlibrary(dplyr)\nlibrary(gapminder)\nlibrary(ggplot2)\nlibrary(glue)\nlibrary(shiny)\nlibrary(shinyWidgets)\n\n## UI\nui <- page_sidebar(\n    sidebar = sidebar(\n        open = \"open\",\n        width = 200,\n        selectInput(\n            inputId = \"option\", \n            label   = \"Paleta\", \n            choices = c(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\"),\n            selected = \"D\"\n        ),\n        prettySwitch(\n            inputId  = \"direction\",\n            label    = \"Invertir paleta\",\n            status   = \"success\",\n            fill     = TRUE\n        ),\n        prettySwitch(\n            inputId = \"binned\",\n            label   = \"Binned\",\n            status  = \"success\",\n            fill    = TRUE\n        )\n    ),\n    verbatimTextOutput(\"code\") |> card(),\n    plotOutput(\"plot\", width = 500) |> card()\n)\n\n## Server\nserver <- function(input, output, session) {\n    \n    output$code <- renderPrint({\n        glue(\n            \n            if (input$binned) {\n                'scatter_base +\n                    scale_color_viridis_b(\n                        option    = \"{input$option}\",\n                        direction = {if (input$direction) -1 else 1}\n                    )'\n            } else {\n                'scatter_base +\n                    scale_color_viridis_c(\n                        option    = \"{input$option}\",\n                        direction = {if (input$direction) -1 else 1}\n                    )'\n            }\n            \n            )\n    })\n\n    ## Plot\n    output$plot <- renderPlot({\n        \n        if (input$binned) {\n            gapminder |> \n            filter(year == 2007) |> \n            ggplot(\n                aes(x = gdpPercap, y = lifeExp, color = pop)\n            ) +\n            geom_point() +\n            labs(\n                x = \"PIB per cápita\",\n                y = \"Esperanza de vida\"\n            ) +\n            theme_minimal(base_size = 8) +\n            scale_color_viridis_b(\n                option    = input$option,\n                direction = if (input$direction) -1 else 1\n            )\n        } else {\n            gapminder |> \n            filter(year == 2007) |> \n            ggplot(\n                aes(x = gdpPercap, y = lifeExp, color = pop)\n            ) +\n            geom_point() +\n            labs(\n                x = \"PIB per cápita\",\n                y = \"Esperanza de vida\"\n            ) +\n            theme_minimal(base_size = 8) +\n            scale_color_viridis_c(\n                option    = input$option,\n                direction = if (input$direction) -1 else 1\n            )\n        }\n        \n        }, res = 96\n    )\n}\n\n## Run app\nshinyApp(ui = ui, server = server)\n```\n\nEstas funciones pueden terminar en:\n\n-   `scale_color_viridis_c()`: para variables continuas.\n\n-   `scale_color_viridis_d()`: para variables discretas.\n\n-   `scale_color_viridis_b()`: para variables continuas que se quieren dividir en intervalos.\n\nPor otro lado, tenemos la familia de paletas de colores `ColorBrewer` [@RColorBrewer], que podemos ver en la siguiente figura:\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Paletas de colores Brewer](1202_scales_files/figure-html/fig-brewer-pals-1.png){#fig-brewer-pals width=672}\n:::\n:::\n\n\n\n\nPara acceder a ellas, podemos utilizar las funciones:\n\n-   `scale_color_distiller()`: para variables continuas\n\n-   `scale_color_brewer()`: para variables discretas\n\n-   `scale_color_fermenter()`: para variables continuas que se quieren dividir en intervalos\n\nA medida que utilices `ggplot2` irás descubriendo paquetes que traen sus propias escalas de colores. Algunos ejemplos son `{ggsci}` [@ggsci], `{MetBrewer}` [@MetBrewer], o `{scico}` [@scico].\n\nEn la siguiente aplicación puedes probar distintas paletas `ColorBrewer`:\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 600\n\n## Load packages\nlibrary(bslib)\nlibrary(dplyr)\nlibrary(gapminder)\nlibrary(ggplot2)\nlibrary(glue)\nlibrary(RColorBrewer)\nlibrary(shiny)\nlibrary(shinyWidgets)\n\n## UI\nui <- page_sidebar(\n    sidebar = sidebar(\n        open = \"open\",\n        width = 200,\n        selectInput(\n            inputId  = \"option\", \n            label    = \"Paleta\", \n            choices  = rownames(brewer.pal.info),\n            selected = \"Reds\"\n        ),\n        prettySwitch(\n            inputId  = \"direction\",\n            label    = \"Invertir paleta\",\n            status   = \"success\",\n            fill     = TRUE\n        ),\n        prettySwitch(\n            inputId = \"binned\",\n            label   = \"Binned\",\n            status  = \"success\",\n            fill    = TRUE\n        )\n    ),\n    verbatimTextOutput(\"code\") |> card(),\n    plotOutput(\"plot\", width = 500) |> card()\n)\n\n## Server\nserver <- function(input, output, session) {\n    \n    output$code <- renderPrint({\n        glue(\n            \n            if (input$binned) {\n                'scatter_base +\n                    scale_color_fermenter(\n                        option    = \"{input$option}\",\n                        direction = {if (input$direction) -1 else 1}\n                    )'\n            } else {\n                'scatter_base +\n                    scale_color_distiller(\n                        option    = \"{input$option}\",\n                        direction = {if (input$direction) -1 else 1}\n                    )'\n            }\n            \n            )\n    })\n\n    ## Plot\n    output$plot <- renderPlot({\n        \n        if (input$binned) {\n            gapminder |> \n            filter(year == 2007) |> \n            ggplot(\n                aes(x = gdpPercap, y = lifeExp, color = pop)\n            ) +\n            geom_point() +\n            labs(\n                x = \"PIB per cápita\",\n                y = \"Esperanza de vida\"\n            ) +\n            theme_minimal(base_size = 8) +\n            scale_color_fermenter(\n                palette = input$option\n            )\n        } else {\n            gapminder |> \n            filter(year == 2007) |> \n            ggplot(\n                aes(x = gdpPercap, y = lifeExp, color = pop)\n            ) +\n            geom_point() +\n            labs(\n                x = \"PIB per cápita\",\n                y = \"Esperanza de vida\"\n            ) +\n            theme_minimal(base_size = 8) +\n            scale_color_distiller(\n                option    = input$option,\n                direction = if (input$direction) -1 else 1\n            )\n        }\n        \n        }, res = 96\n    )\n}\n\n## Run app\nshinyApp(ui = ui, server = server)\n```\n\n#### Paletas manuales\n\nEn algunos paquetes tenemos una infinidad de paletas de colores predefinidas, pero puede haber ocasiones en las que prefiramos definir nosotros mismos la paleta de colores. Para ello, tenemos tres funciones que nos permiten definir una paleta de colores continua de forma manual:\n\n-   `scale_color_gradient()`: a partir de dos colores, generamos un gradiente (definimos color mínimo y color máximo).\n\n-   `scale_color_gradient2()`: a partir de tres colores (siendo el tercero el punto medio)\n\n-   `scale_color_gradientn()`: a partir de *n* colores\n\nVamos a ver estos tres en acción:\n\n::: panel-tabset\n## Gradient\n\nEn este caso, debemos especificar dos colores, y el resto se interpola entre ellos:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscatter_base +\n    scale_color_gradient(\n        name = \"Población\",\n        low  = \"blue\",\n        high = \"green\"\n    )\n```\n\n::: {.cell-output-display}\n![](1202_scales_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n\n\n\n## Gradient2\n\nEn este caso, especificaremos además el color del medio. Por defecto, este punto es el valor de 0, por lo que podemos modificarlo a nuestro parecer con `midpoint`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscatter_base +\n    scale_color_gradient2(\n        name = \"Población\",\n        low  = \"blue\",\n        mid  = \"red\",\n        high = \"green\",\n        midpoint = 7e8\n    )\n```\n\n::: {.cell-output-display}\n![](1202_scales_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\n\n\n## Gradientn\n\nFinalmente, esta es una de las opciones más flexibles ya que en muchas ocasiones utilizaremos paletas de colores de varios colores que vienen dentro de algún paquete, y que en lugar de traer funciones del tipo `scale_color_*`, traen vectores de códigos hexadecimales con los colores. Un ejemplo son las paletas que vienen dentro de la función `hcl.colors()`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscatter_base +\n    scale_color_gradientn(\n        name   = \"Población\",\n        colors = hcl.colors(50, palette = \"Spectral\")\n    )\n```\n\n::: {.cell-output-display}\n![](1202_scales_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n:::\n\n\n\n\nLas paletas pueden explorarse [aquí](https://colorspace.r-forge.r-project.org/articles/hcl_palettes.html).\n:::\n",
    "supporting": [
      "1202_scales_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}