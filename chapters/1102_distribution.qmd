---
execute: 
  warning: false
editor_options: 
  chunk_output_type: console
filters: 
    - webr
webr:
    packages: ["dplyr", "ggplot2"]
---

# Gr치ficos de distribuci칩n {#sec-plot-distribution}

Los gr치ficos de distribuci칩n son una forma de visualizar la distribuci칩n de los datos. En este tipo de gr치ficos, se muestra la frecuencia de los valores de una variable o de un conjunto de variables. Los gr치ficos de distribuci칩n son 칰tiles para identificar patrones en los datos, como la presencia de valores at칤picos, la simetr칤a de la distribuci칩n, la presencia de m칰ltiples modas, entre otros. Generalmente, los gr치ficos de distribuci칩n se utilizan para visualizar **una sola variable num칠rica** aunque en la @fig-vis-classification se muestra que tambi칠n es posible visualizar **dos variables num칠ricas** mediante el uso de gr치ficos de dispersi칩n (**scatter plot**).

En este cap칤tulo, veremos los siguientes tipos de gr치ficos de distribuci칩n:

1.  Histogramas (**histogram**)

2.  Gr치ficos de densidad (**density plot**)

3.  Gr치ficos de cajas (**box plot**)

4.  Gr치ficos de viol칤n (**violin plot**)

::: callout-info
Los gr치ficos de dispersi칩n los veremos dentro del cap칤tulo de gr치ficos de relaci칩n.
:::

En este cap칤tulo vamos a trabajar con dos datasets:

-   `iris`: se utilizar치 para los ejemplos utilizados en las explicaciones (ver [Tipos de visualizaci칩n](#sec-visualization-types){target="_blank"}).

-   `inventario`: ser치n los datos que utilizar치n los alumnos para los ejercicios propuestos (ver @sec-vis-data).

Para comenzar, vamos a cargar los paquetes necesarios y a leer los datos que utilizaremos en este cap칤tulo.

```{r}
#| include: false
## Paquetes internos
library(patchwork)
```

```{r}
# Cargar paquetes
library(dplyr)
library(readr)
library(ggplot2)
# Cargar datos
inventario_tbl <- read_rds("../data/inventario_prep.rds")
```

## Objetivos

Al final de este cap칤tulo, ser치s capaz de:

-   Utilizar etiquetas y temas predise침ados en `{ggplot2}`

-   Crear histogramas en `{ggplot2}`

-   Crear gr치ficos de densidad en `{ggplot2}`

-   Crear gr치ficos de cajas en `{ggplot2}`

-   Crear gr치ficos de viol칤n en `{ggplot2}`

-   A침adir l칤neas a los gr치ficos

-   A침adir puntos con res칰menes estad칤sticos a los gr치ficos

## Histogramas

Los histogramas son una forma de visualizar la distribuci칩n de una variable num칠rica. En un histograma, los valores de la variable se agrupan en intervalos y se muestra la frecuencia de los valores en cada intervalo. Los histogramas son 칰tiles para identificar la forma de la distribuci칩n de los datos, la presencia de valores at칤picos y la presencia de m칰ltiples modas.

Para crear un histograma en `ggplot2`, utilizamos la funci칩n `geom_histogram()`. Tiene dos argumentos de gran importancia:

-   `bins`: n칰mero de intervalos en los que se agrupar치n los datos. Si no se especifica, `{ggplot2}` utilizar치 30 intervalos.

-   `binwidth`: ancho de los intervalos. Si se especifica, `{ggplot2}` calcular치 el n칰mero de intervalos autom치ticamente.

::: callout-note
Estos dos argumentos son mutuamente excluyentes. Si se especifica `bins`, `{ggplot2}` ignorar치 `binwidth`.
:::

Vamos a ver la diferencia entre estos dos argumentos viendo la distribuci칩n de la longitud de los p칠talos de las flores del dataset `iris`:

::: panel-tabset
## N칰mero de intervalos

Al especificar el n칰mero de intervalos lo que hacemos es b치sicamente indicar el n칰mero de barras que queremos generar:

```{shinylive-r}
#| standalone: true
#| viewerHeight: 600

## Load packages
library(bslib)
library(ggplot2)
library(glue)
library(shiny)

## UI
ui <- page_sidebar(
    sidebar = sidebar(
        open = "open",
        width = 200,
        sliderInput("bins", "N칰mero de intervalos", min = 1, max = 30, value = 15),
    ),
    verbatimTextOutput("code") |> card(),
    plotOutput("plot", width = 500) |> card()
)

## Server
server <- function(input, output, session) {
    
    output$code <- renderPrint({
        glue(
            'ggplot(iris, aes(x = Petal.Length)) +
                    geom_histogram(bins = {input$bins}, fill = "#0073C2FF", color = "white") +
                    labs(
                        title = "Distribuci칩n de longitud del p칠talo", 
                        x = "Longitud (mm)", 
                        y = "Frecuencia"
                    )'
            )
    })

    ## Plot
    output$plot <- renderPlot({
        ggplot(iris, aes(x = Petal.Length)) +
            geom_histogram(bins = input$bins, fill = "#0073C2FF", color = "white") +
            labs(
                title = "Distribuci칩n de longitud del p칠talo", 
                x = "Longitud (cm)", 
                y = "Frecuencia"
            ) +
            theme_gray(base_size = 8)
    }, res = 96)
}

## Run app
shinyApp(ui = ui, server = server)
```

## Ancho del intervalo

Cuando seleccionamos el ancho del intervalo (*binwidth*), estamos seleccionando el tama침o del intervalo en las unidades de la variable que estamos evaluando. Por ejemplo, si seleccionamos un ancho de banda de 0.3 para la longitud del p칠talo, estamos indicando que cada barra agrupar치 observaciones de 3 en 3 mil칤metros. De 0-0.3 tendremos el primer intervalo, de 0.3-0.6 el segundo, y as칤 sucesivamente.

```{shinylive-r}
#| standalone: true
#| viewerHeight: 600

## Load packages
library(bslib)
library(ggplot2)
library(glue)
library(shiny)

## UI
ui <- page_sidebar(
    sidebar = sidebar(
        open = "open",
        width = 200,
        sliderInput("bins", "Ancho del intervalo", min = 0.1, max = 2, value = .2, step = .1),
    ),
    verbatimTextOutput("code") |> card(),
    plotOutput("plot", width = 500) |> card()
)

## Server
server <- function(input, output, session) {
    
    output$code <- renderPrint({
        glue(
            '
            ggplot(iris, aes(x = Petal.Length)) +
                    geom_histogram(binwidth = {input$bins}, fill = "#0073C2FF", color = "white") +
                    labs(
                        title = "Distribuci칩n de longitud del p칠talo", 
                        x = "Longitud (mm)", 
                        y = "Frecuencia"
                    )'
            )
    })

    ## Plot
    output$plot <- renderPlot({
        ggplot(iris, aes(x = Petal.Length)) +
            geom_histogram(binwidth = input$bins, fill = "#0073C2FF", color = "white") +
            labs(
                title = "Distribuci칩n de longitud del p칠talo", 
                x     = "Longitud (mm)", 
                y     = "Frecuencia"
            ) +
            theme_gray(base_size = 8)
    }, res = 96)
}

## Run app
shinyApp(ui = ui, server = server)
```
:::

::: callout-tip
Los c칩digos hexadecimales son una forma de representar colores en HTML y CSS. En R, podemos utilizarlos para cambiar el color de los gr치ficos. En este caso, el color `#0073C2FF` representa un azul claro. Puedes utilizar generadores de colores online como [este](https://htmlcolorcodes.com/){target="_blank"} para elegir un color.
:::

Un histograma es b치sicamente esto. Para el color de relleno utilizamos el argumento `fill` y para el color del contorno utilizamos el argumento `color`, y este patr칩n seguir치 siendo el mismo para los otros tipos de gr치ficos de `{ggplot2}`.

Tambi칠n te habr치s dado cuenta que hemos a침adido una funci칩n nueva que es `labs()`. Esta funci칩n nos permite a침adir etiquetas al gr치fico como:

-   `title`: t칤tulo del gr치fico.

-   `subtitle`: subtitulo del gr치fico.

-   `x`: t칤tulo del eje x.

-   `y`: t칤tulo del eje y.

-   `caption`: pie de figura.

Si bien es cierto que los histogramas son una forma de visualizar la distribuci칩n de una sola variable, tambi칠n podemos crear histogramas para comparar la distribuci칩n de una variable num칠rica entre diferentes grupos. Esto puede ser muy conveniente, ya que si nos fijamos en las figuras anteriores, podemos ver que si indicamos el n칰mero de intervalos adecuado sigue una [distribuci칩n bimodal](#0){target="_blank"}.

Vamos a ver qu칠 pasa si comparamos la distribuci칩n de la longitud de los p칠talos de las flores del *dataset* `iris` entre las diferentes especies de flores. Para ello, utilizamos el argumento `fill` en la funci칩n `aes()` para indicar la variable categ칩rica que queremos comparar:

```{r}
#| label: fig-distribution-species
#| fig-cap: Distribuci칩n de longitud del p칠talo por especie

iris |> 
    ggplot(
        aes(x = Petal.Length, fill = Species)
    ) +
    geom_histogram(bins = 30, color = "white") +
    labs(
        title    = "Distribuci칩n de longitud del p칠talo por especie", 
        subtitle = "La especie I. setosa tiene una longitud de p칠talo menor que I. versicolor e I. virginica",
        x        = "Longitud (mm)", 
        y        = "Frecuencia",
        caption  = "Autor: Adri치n Cidre"
    ) +
    theme_minimal()
```

Ah치 游뱂! Gracias a utilizar una est칠tica m치s podemos ver que la distribuci칩n no es bimodal, si no que son distribuciones de especies de flores distintas. En esencia, a침adir una est칠tica m치s puede ser visto como a침adir una dimensi칩n m치s al gr치fico.

::: callout-note
A partir de ahora vamos a ir a침adiendo nuevas funciones y argumentos a nuestros gr치ficos. No te preocupes si no entiendes todo a la primera, poco a poco iremos viendo c칩mo se utilizan y para qu칠 sirven. En este caso hemos a침adido `theme_minimal()` que nos permite cambiar el tema base del gr치fico. Existen una serie de temas predefinidos que empiezan por `theme_*()`.
:::

## Gr치ficos de densidad

Los gr치ficos de densidad son una forma de visualizar la distribuci칩n de una variable num칠rica. A diferencia de los histogramas, los gr치ficos de densidad no agrupan los datos en intervalos, sino que muestran la estimaci칩n de densidad kernel de los datos. Los gr치ficos de densidad son 칰tiles para identificar la forma de la distribuci칩n de los datos, ya que son una versi칩n suavizada de los histogramas.

Para crear un gr치fico de densidad en `{ggplot2}`, utilizamos la funci칩n `geom_density()`. B치sicamente, se va a generar una l칤nea que nos va a indicar la densidad de probabilidad de los datos. Como es una l칤nea, tiene una serie de est칠ticas que podemos modificar a continuaci칩n:

```{shinylive-r}
#| standalone: true
#| viewerHeight: 600

## Load packages
library(bslib)
library(ggplot2)
library(glue)
library(shiny)

## UI
ui <- page_sidebar(
    sidebar = sidebar(
        open  = "open",
        width = 200,
        selectInput(
            inputId  = "linetype_input",
            label    = "Linetype",
            choices  = c("solid", "dashed", "dotted",
                         "dotdash", "longdash", "twodash"),
            selected = "solid"
        ),
        sliderInput(
            inputId = "linewidth_input",
            label   = "Linewidth",
            min     = 0,
            max     = 4,
            value   = 1,
            step    = .5
        ),
        checkboxInput(
            inputId = "fill_input",
            label   = "Rellenar?",
            value   = FALSE
        )
    ),
    verbatimTextOutput("code") |> card(),
    plotOutput("plot", width = 500) |> card()
)

## Server
server <- function(input, output, session) {
    
    output$code <- renderPrint({
        
        if (input$fill_input) {
            glue(
            'ggplot(iris, aes(x = Petal.Length)) +
                geom_density(
                    color     = "darkred",
                    fill      = "gray30",
                    linetype  = "{input$linetype_input}",
                    linewidth = {input$linewidth_input}
                ) +
                labs(
                    title = "Distribuci칩n de longitud del p칠talo", 
                    x     = "Longitud (mm)", 
                    y     = "Probabilidad (%)"
                ) +
                theme_bw(base_size = 8)'
            )
        } else {
            glue(
            'ggplot(iris, aes(x = Petal.Length)) +
                geom_density(
                    color     = "darkred",
                    linetype  = "{input$linetype_input}",
                    linewidth = {input$linewidth_input}
                ) +
                labs(
                    title = "Distribuci칩n de longitud del p칠talo", 
                    x     = "Longitud (mm)", 
                    y     = "Probabilidad (%)"
                ) +
                theme_bw()'
            )
        }
    })

    ## Plot
    output$plot <- renderPlot({
        ggplot(iris, aes(x = Petal.Length)) +
            geom_density(
                color     = "darkred",
                linetype  = input$linetype_input,
                linewidth = input$linewidth_input,
                fill      = if (input$fill_input) "gray30" else NA
            ) +
            labs(
                title = "Distribuci칩n de longitud del p칠talo", 
                x     = "Longitud (mm)", 
                y     = "Probabilidad (%)"
            ) +
            theme_bw(base_size = 8)
    }, res = 96)
}

## Run app
shinyApp(ui = ui, server = server)
```

### Ejercicio 1

Finalmente, al igual que con los histogramas, podemos comparar la distribuci칩n de la longitud del p칠talo entre las diferentes especies de flores del *dataset* `iris`. Te atreves a intentar a침adir la parte del c칩digo que falta? El resultado deber칤a ser el indicado en la @fig-distribution-ej1:

::: panel-tabset
## Gr치fico esperado

Intenta replicar este gr치fico en la pesta침a "Ejercicio"

```{r}
#| label: fig-distribution-ej1
#| fig-cap: Resultado esperado del ejercicio 1
#| echo: false
iris |> 
    ggplot(aes(x = Petal.Length)) +
    geom_density(
        aes(fill = Species),
        color    = NA,
        alpha    = .8
    ) +
    labs(
        title = "Distribuci칩n de longitud del p칠talo",
        x     = "Longitud (mm)", 
        y     = "Probabilidad (%)"
    ) +
    theme_bw()
```

## Ejercicio

En total hay que a침adir tres elementos:

-   Transparencia (necesaria para poder ver la superposici칩n de densidades)

-   Eliminar color de contorno

-   Crear un gr치fico de densidad por especie dentro del mismo gr치fico

```{webr-r}
iris |> 
    ggplot(
        aes(x = Petal.Length)
    ) +
    geom_density() +
    labs(
        title = "Distribuci칩n de longitud del p칠talo",
        x     = "Longitud (mm)", 
        y     = "Probabilidad (%)"
    ) +
    theme_bw()
```

## Soluci칩n

El argumento `aes(fill = Species)` tambi칠n se puede introducir en la funci칩n `ggplot()`.

```{r}
#| label: fig-distribution-ej1-sol
#| fig-cap: Resultado del ejercicio 1
iris |> 
    ggplot(aes(x = Petal.Length)) +
    geom_density(
        aes(fill = Species),
        color    = NA,
        alpha    = .8
    ) +
    labs(
        title = "Distribuci칩n de longitud del p칠talo",
        x     = "Longitud (mm)", 
        y     = "Probabilidad (%)"
    ) +
    theme_bw()

```
:::

### Ejercicio 2

En los siguientes ejercicios vamos a trabajar con los datos de inventario. Vamos a empezar cargando los datos, convertirlos a `tibble` y vamos a ver de nuevo su estructura:

```{webr-r}
## Url de los datos
url <- "https://cidree.github.io/MG_datasets/inventario_prep.csv"
inventario_tbl <- read.csv(url) |> as_tibble()
## Estructura datos
inventario_tbl
```

El ejercicio consiste en generar un histograma de la distribuci칩n diam칠trica (en cent칤metros), adem치s generando un gr치fico por especie. Utiliza el siguiente bloque de c칩digo y practica todo lo que hemos visto hasta ahora:

::: panel-tabset
## Ejercicio 2

```{webr-r}
## Escribir c칩digo aqu칤

```

## Resultado

El siguiente c칩digo es una de muchas opciones.

```{r}
#| label: fig-distribution-ej2
#| fig-cap: Resultado del ejercicio 2
inventario_tbl |> 
    ggplot(
        aes(x = dbh_mm / 10, fill = nombre_ifn)
    ) +
    geom_histogram(
        bins  = 25, 
        color = "snow"
    ) +
    labs(
        title = "Distribuci칩n diam칠trica por especie",
        x     = "Di치metro (cm)", 
        y     = "Frecuencia",
        fill  = "Especie"
    ) +
    theme_minimal()
```
:::

En la @fig-distribution-ej2 hemos a침adido el argumento `fill` dentro de la funci칩n `labs()`. Cuando utilizamos una est칠tica como color, fill, shape... dentro de `aes()`, podemos utilizar el nombre de esta est칠tica dentro de `labs()` para modificar el t칤tulo de la leyenda.

### Ejercicio 3

Generar un gr치fico de densidad para la altura de los 치rboles por especie.

::: panel-tabset
## Ejercicio 3

```{webr-r}
## Escribir c칩digo aqu칤

```

## Resultado

El siguiente c칩digo es una de muchas opciones.

```{r}
#| label: fig-distribution-ej3
#| fig-cap: Resultado del ejercicio 3
inventario_tbl |> 
    ggplot(
        aes(x = height_m, fill = nombre_ifn)
    ) +
    geom_density(
        alpha = .7
    ) +
    labs(
        title = "Distribuci칩n de alturas por especie",
        x     = "Altura (m)", 
        y     = "Probabilidad (%)",
        fill  = "Especie"
    ) +
    theme_minimal()
```
:::

### Extra - A침adir l칤neas

Algo com칰n es a침adir l칤neas a los gr치ficos que representen alg칰n valor importante como la media o la mediana. En esta breve secci칩n vamos a ver como a침adir estas dos l칤neas a un histograma.

Vamos a empezar con un histograma de la distribuci칩n diam칠trica de *P. sylvestris*:

```{r}
#| label: fig-distribution-ps
#| fig-cap: Distribuci칩n diam칠trica de *Pinus sylvestris*
inventario_tbl |> 
    filter(nombre_ifn == "Pinus sylvestris") |> 
    ggplot(
        aes(x = dbh_mm)
    ) +
    geom_histogram(
        color = "snow",
        fill  = "#0073C2FF"
    ) +
    theme_bw()
```

La idea es a침adir una **l칤nea vertical** que nos se침ale donde se encuentran la media y la mediana. Para ello, tenemos la funci칩n `geom_vline()`. El argumento m치s importante es:

-   `xintercept`: valor en el eje x donde se va a situar la l칤nea.

El resto de argumentos pueden consultarse en la documentaci칩n de la funci칩n, y ser치n los comunes a geometr칤as de l칤nea: *color, linewidth, linetype...*

```{r}
#| label: fig-distribution-ps-lines
#| fig-cap: Distribuci칩n diam칠trica de *Pinus sylvestris* con l칤neas
## Filtrar datos de Pinus sylvestris
## Crear columna de di치metro en cm
psylvestris_tbl <- inventario_tbl |> 
    filter(nombre_ifn == "Pinus sylvestris") |> 
    mutate(
        dbh_cm = dbh_mm / 10
    )
    
## Gr치fico
psylvestris_tbl |> 
    ggplot(
        aes(x = dbh_cm)
    ) +
    geom_histogram(
        color = "snow",
        fill  = "#0073C2FF",
        alpha = .7  
    ) +
    geom_vline(
        aes(xintercept = mean(psylvestris_tbl$dbh_cm, na.rm = TRUE)),
        color = "darkred",
        size  = 1
    ) +
    geom_vline(
        xintercept = median(psylvestris_tbl$dbh_cm, na.rm = TRUE),
        color      = "darkorange",
        size       = 1
    ) +
    labs(
        title = "Distribuci칩n diam칠trica de Pinus sylvestris",
        x     = "Di치metro (cm)", 
        y     = "Frecuencia"
    ) +
    theme_bw()

```

Como solamente utilizamos un valor que generamos con `mean()` y `median()`, no es necesario utilizar `aes()` en `geom_vline()`. Se muestran ambas opciones para mostrar que es posible utilizar cualquiera de las dos opciones.

## Boxplot

Los *boxplot* (gr치ficos de cajas o bigotes) son una forma de visualizar la distribuci칩n de una variable num칠rica. En un gr치fico de cajas, se muestra un resumen de la distribuci칩n de los datos, incluyendo la mediana, los cuartiles y los valores at칤picos. Los gr치ficos de cajas son 칰tiles para identificar la presencia de valores at칤picos y la simetr칤a de la distribuci칩n.

![Partes de un boxplot. Fuente: [R Graph Gallery](https://r-graph-gallery.com/boxplot.html){target="_blank"}](/images/boxplot.png){#fig-boxplot-explanation fig-align="center"}

Aunque es un gr치fico que nos da un resumen estad칤stico muy bueno, es un gr치fico que **nunca** se debe utilizar solo. Un boxplot nos est치 mostrando cinco valores principales: m칤nimo, primer cuartil, mediana, tercer cuartil y m치ximo. Sin embargo, no sabemos nada del resto de valores. F칤jate en los siguientes boxplot:

```{r}
#| label: fig-boxplot-ex
#| fig-cap: Boxplots con datos ficticios con la misma forma
#| echo: false
## Crear valores
set.seed(123)
rand_vals <- sample(1:100, 500, replace = TRUE)
## Crear boxplot
g1 <- data.frame(x = rand_vals, y = "A") |> 
    ggplot(
        aes(x = y, y = x)
    ) +
    geom_boxplot() +
    geom_jitter(
        alpha = .3,
        position = position_jitter(height = 0)
    ) +
    labs(
        title = "Boxplot 1",
        x     = NULL, 
        y     = NULL
    ) +
    theme_minimal()

## Valores resumen
summary_vals <- data.frame(
    y = c(
        min(rand_vals, na.rm = TRUE) |> rep(20),
        quantile(rand_vals, .25, na.rm = TRUE) |> rep(20),
        median(rand_vals, na.rm = TRUE) |> rep(20),
        quantile(rand_vals, .75, na.rm = TRUE) |> rep(20),
        max(rand_vals, na.rm = TRUE) |> rep(20)
    ),
    x = "A"
)

## Crear boxplot
g2 <- summary_vals |> 
    ggplot(
        aes(x = x, y = y)
    ) +
    geom_boxplot() +
    geom_jitter(alpha = .3, position = position_jitter(height = 0)) +
    labs(
        title = "Boxplot 2",
        x     = NULL, 
        y     = NULL
    ) +
    theme_minimal()

## Visualizar 
g1 + g2
```

Ambos gr치ficos tienen exactamente la misma forma, pero como puedes ver en los puntos, los datos son muy distintos. Es por ello que se suelen utilizar variantes del *boxplot* o el *boxplot* combinado con otras geometr칤as como el *violin plot*.

Una vez vista esta debilidad de los *boxplot*, vamos a generar uno para la distribuci칩n de la longitud de los p칠talos del *dataset* de iris. En este caso, va a ser el primer gr치fico de distribuci칩n donde utilicemos ambas est칠ticas de los ejes `x` e `y`.

La funci칩n `geom_boxplot()` tiene un mont칩n de argumentos que podemos modificar. Los *outliers* se representan como puntos, y por ende, podemos modificar todo aquello relacionado con ellos con argumentos que empiezan por `outlier.*`. Por ejemplo, `outlier.shape`, `outlier.size`, `outlier.color`...

```{r}
#| label: fig-boxplot-petal
#| fig-cap: Boxplot de la longitud del p칠talo
base_boxplot <- iris |> 
    ggplot(
        aes(x = Species, y = Petal.Length)
    ) +
    geom_boxplot(
        fill          = "orangered",
        alpha         = .4,
        outlier.shape = 21,
        outlier.size  = 3,
        outlier.color = "black",
        varwidth      = TRUE
    ) +
    labs(
        title = "Distribuci칩n de la longitud del p칠talo por especie",
        x     = "Especie", 
        y     = "Longitud (mm)"
    ) +
    theme_minimal()
    
base_boxplot
```

Hemos guardo el gr치fico en un objeto llamado `base_boxplot` para poder a침adir m치s elementos en la siguiente secci칩n.

### Boxplot + Jitter

Para a침adir la distribuci칩n de los datos en un boxplot, podemos utilizar la funci칩n `geom_point()`:

```{r}
#| label: fig-boxplot-petal-point
#| fig-cap: Boxplot de la longitud del p칠talo con geom_point()
base_boxplot +
    geom_point()
```

Sin embargo, como puedes ver, los puntos est치n superpuestos. Para evitar esto, podemos utilizar la funci칩n `position_jitter()` dentro del argumento `position` que nos permite a침adir un poco de ruido a los puntos para que no se superpongan. Esto significa que los puntos tendr치n un determinando porcentaje (0-1) de variaci칩n en el eje `x` con el argumento `width` y en el eje `y` con el argumento `height`. Utiliza la siguiente herramienta para ver como funciona:

```{shinylive-r}
#| standalone: true
#| viewerHeight: 600

## Load packages
library(bslib)
library(ggplot2)
library(glue)
library(shiny)

## UI
ui <- page_sidebar(
    sidebar = sidebar(
        open = "open",
        width = 200,
        sliderInput("width_j", "Width", min = 0, max = 1, value = .5, step = .1),
        sliderInput("height_j", "Height", min = 0, max = 1, value = .5, step = .1)
    ),
    verbatimTextOutput("code") |> card(),
    plotOutput("plot", width = 500) |> card()
)

## Server
server <- function(input, output, session) {
    
    output$code <- renderPrint({
        glue(
            '
            base_boxplot +
                geom_point(
                    position = position_jitter(
                        width  = {input$width_j},
                        height = {input$height_j}
                    ),
                    alpha    = .7
                )'
            )
    })

    ## Plot
    output$plot <- renderPlot({
        ggplot(iris, aes(x = Species, y = Petal.Length)) +
            geom_boxplot(
                fill          = "orangered",
                alpha         = .4,
                outlier.shape = 21,
                outlier.size  = 3,
                outlier.color = "black",
                varwidth      = TRUE
            ) +
            labs(
                title = "Distribuci칩n de la longitud del p칠talo por especie",
                x     = "Especie", 
                y     = "Longitud (mm)"
            ) +
            theme_minimal() +
                        geom_point(
                            position = position_jitter(
                                width  = {input$width_j},
                                height = {input$height_j}
                            ),
                            alpha    = .7
                        ) +
                    theme_gray(base_size = 8)
    }, res = 96)
}

## Run app
shinyApp(ui = ui, server = server)
```

Si ambos son igual a 0, significa que no se a침ade ruido. si aumentamos `width`, veremos que los datos se mantienen en sus valores originales seg칰n la variable de longitud del p칠talo, pero se mueven aleatoriamente a lo largo del eje `x`. De este modo podemos ver mejor la distribuci칩n. No obstante, esto es recomendable solamente en variables categ칩ricas para que los puntos no est칠n unos encima de otros. En variables num칠ricas no tiene sentido ya que estamos modificando los datos. Es decir, en este ejemplo `height` debe ser igual a 0.

::: callout-note
Si utilizamos un valor igual o superior a 0.5 los puntos de distintas categor칤as se superpondr치n.
:::

Como esta geometr칤a es muy com칰n, `{ggplot2}` tiene la funci칩n `geom_jitter()` que es un atajo para `geom_point(position = position_jitter())`:

```{r}
#| label: fig-boxplot-petal-jitter
#| fig-cap: Boxplot de la longitud del p칠talo con geom_jitter()
base_boxplot +
    geom_jitter(height = 0, width = .2)
```

### Ejercicio 4

Generar un *boxplot* de la distribuci칩n diam칠trica por especie. Adem치s, a침adir la distribuci칩n de los puntos. Para practicar, utiliza la documentaci칩n de `geom_boxplot()` para modificar distintos argumentos.

::: panel-tabset
## Ejercicio 4

```{webr-r}
## Escribir c칩digo aqu칤

```

## Resultado

El siguiente c칩digo es una de muchas opciones.

```{r}
#| label: fig-boxplot-ej4
#| fig-cap: Resultado del ejercicio 4

## Crear boxplot
inventario_tbl |> 
    ggplot(
        aes(x = nombre_ifn, y = dbh_mm / 10)
    ) +
    geom_boxplot(
        fill          = "#82BE1F",
        outlier.shape = 21,
        outlier.size  = 3,
        outlier.fill  = "#E121DB",
        varwidth      = TRUE,
        width         = .5
    ) +
    geom_jitter(
        color = "#7D9E69",
        height = 0,
        width  = .4,
        alpha  = .3
    ) +
    labs(
        title = "Distribuci칩n diam칠trica por especie",
        x     = "Especie", 
        y     = "Di치metro (cm)"
    ) +
    theme_minimal()
```
:::

### Extra - A침adir media

Tambi칠n es posible a침adir la localizaci칩n de la media mediante un punto en un *boxplot*. Para ello, utilizamos la funci칩n `geom_point()`:

```{r}
base_boxplot +
    geom_point()
```

Bueeeno 游땐... Recuerdas cu치ndo habl치bamos de las transformaciones estad칤sticas en @sec-components? Pues por defecto `geom_point()` utiliza `stat = "identity"`, que quer칤a decir que no se aplica ninguna transformaci칩n, y por lo tanto $f(x) = x$. Ser치 `{ggplot2}` tan m치gico que nos dejar치 decir que realice una transformaci칩n estad칤stica en la que convierta los puntos a la media? S칤, pero debemos utilizar la transformaci칩n estad칤stica `summary`, y elegir una funci칩n de resumen con el argumento `fun`. En realidad, podemos a침adir varias funciones que puedes probar aqu칤:

```{shinylive-r}
#| standalone: true
#| viewerHeight: 600

## Load packages
library(bslib)
library(ggplot2)
library(glue)
library(shiny)

## UI
ui <- page_sidebar(
    sidebar = sidebar(
        open = "open",
        width = 200,
        selectInput(
            inputId = "fun_input", 
            label   = "Funci칩n", 
            choices = c("min", "max", "mean", "median", "quantile")
        )
    ),
    verbatimTextOutput("code") |> card(),
    plotOutput("plot", width = 500) |> card()
)

## Server
server <- function(input, output, session) {
    
    output$code <- renderPrint({
        glue(
            '
            base_boxplot +
                geom_point(
                    stat  = "summary",
                    fun   = {input$fun_input},
                    shape = 4,
                    size  = 3,
                    color = "red"
                )'
            )
    })

    ## Plot
    output$plot <- renderPlot({
        ggplot(iris, aes(x = Species, y = Petal.Length)) +
            geom_boxplot(
                fill          = "orangered",
                alpha         = .4,
                outlier.shape = 21,
                outlier.size  = 3,
                outlier.color = "black",
                varwidth      = TRUE
            ) +
            labs(
                title = "Distribuci칩n de la longitud del p칠talo por especie",
                x     = "Especie", 
                y     = "Longitud (mm)"
            ) +
            theme_minimal() +
            geom_point(
                stat  = "summary",
                fun   = {input$fun_input},
                shape = 4,
                size  = 3,
                color = "red"
            ) +
            theme_gray(base_size = 8)
    }, res = 96)
}

## Run app
shinyApp(ui = ui, server = server)
```

Cualquier funci칩n que se pueda aplicar a un vector num칠rico, se puede a침adir dentro del argumento `fun`, y esto incluye funciones personalizadas.

::: callout-tip
Si quieres ver las opciones del argumento `shape`, puedes consultar la documentaci칩n de la funci칩n `points()`.

![Opciones de puntos para el argumento \`shape\`](/images/point-shape.png){#fig-point-shapes fig-align="center"}
:::

## Violin plot

El *violin plot* es una forma de visualizar la distribuci칩n de una variable num칠rica. A diferencia del *boxplot*, el *violin plot* muestra la distribuci칩n de los datos de forma m치s detallada, de forma que no es necesario a침adir una capa de puntos **jitter** para tener una idea de la distribuci칩n de los datos.

```{r}
#| label: fig-violin-petal
#| fig-cap: Violin plot de la longitud del p칠talo
base_violin <- iris |> 
    ggplot(
        aes(x = Species, y = Petal.Length)
    ) +
    geom_violin(
        fill  = "#0073C2FF",
        color = "white"
    ) +
    labs(
        title = "Distribuci칩n de la longitud del p칠talo por especie",
        x     = "Especie", 
        y     = "Longitud (mm)"
    ) +
    theme_minimal()
  
base_violin
```

En la @fig-violin-petal vemos que los gr치ficos son m치s o menos anchos. Cuanto m치s anchos, m치s datos hay en esa zona. Para tener una idea de lo que significa, podemos a침adir una capa de puntos y as칤 entenderlo mejor:

```{r}
#| label: fig-violin-petal-jitter
#| fig-cap: Violin plot de la longitud del p칠talo con `geom_jitter()`
base_violin +
  geom_jitter(
      alpha  = .5,
      height = 0
  ) 
```

Como puedes ver, los puntos se distribuyen en funci칩n de la anchura del *violin plot*. Si la anchura es mayor, significa que hay m치s datos en esa zona.

Opciones interesantes para modificar el *violin plot* son:

-   `trim`: si es `FALSE`, el *violin plot* se extender치 hasta los valores extremos de los datos. Si es `TRUE` (por defecto), se extender치 hasta el valor m치s extremo que no sea un valor at칤pico.

-   `scale`: si es `area` (por defecto), el 치rea de cada *violin* es proporcional al n칰mero de observaciones. Si es `count`, el ancho de cada *violin* es proporcional al n칰mero de observaciones.

-   `draw_quantiles`: si es `TRUE`, se dibujar치n los cuantiles del 25%, 50% y 75% en el *violin plot*.

```{r}
#| label: fig-violin-petal-options
#| fig-cap: Violin plot de la longitud del p칠talo con opciones
iris |> 
    ggplot(
        aes(x = Species, y = Petal.Length)
    ) +
    geom_violin(
        fill  = "#0073C2FF",
        color = "white",
        trim  = TRUE,
        scale = "area",
        draw_quantiles = c(.25, .5, .75),
    ) +
    labs(
        title = "Distribuci칩n de la longitud del p칠talo por especie",
        x     = "Especie", 
        y     = "Longitud (mm)"
    ) +
    theme_minimal()
```

### Ejercicio 5 {#sec-ej5}

Generar un *violin plot* de la distribuci칩n diam칠trica por especie de `inventario_tbl`. Adem치s, a침adir una capa de puntos para ver la distribuci칩n de los datos. Visualizar la diferencia entre `scale = "area"` y `scale = "count"` y quedarse con el que te parezca m치s adecuado (en la pesta침a "Resultado" se explica cu치l es la mejor opci칩n).

El resultado de este ejercicio lo utilizaremos en @sec-ej6, as칤 que guarda el *violin plot* en un objeto llamado `violin_ej5_gg`.

::: panel-tabset
## Ejercicio 5

```{webr-r}
## Escribir c칩digo aqu칤
```

## Resultado

El siguiente c칩digo es una de muchas opciones.

Con `scale = "count"`, vemos que de *P. sylvestris* tenemos muchos m치s datos. Si utilizamos `scale = "area`, esto no lo sabemos. Por lo tanto, es mejor utilizar `scale = "count"`.

```{r}
#| label: fig-violin-ej5
#| fig-cap: Resultado del ejercicio 5
## Crear violin plot
violin_ej5_gg <- inventario_tbl |> 
    ggplot(
        aes(x = nombre_ifn, y = dbh_mm / 10)
    ) +
    geom_violin(
        fill  = "#82BE1F",
        color = "transparent",
        trim  = TRUE,
        scale = "count"
    ) +
    labs(
        title = "Distribuci칩n diam칠trica por especie",
        x     = "Especie", 
        y     = "Di치metro (cm)"
    ) +
    theme_bw()
## Imprimir
violin_ej5_gg
```
:::

### Ejercicio 6 {#sec-ej6}

En la @sec-ej5 hemos generado un diam칠trica por especie que guardamos como `violin_ej5_gg`. A este gr치fico, a침adir un *boxplot* y un punto que represente la media de la distribuci칩n.

::: panel-tabset
## Ejercicio 6

```{webr-r}
## Escribir c칩digo aqu칤
```

## Resultado

El siguiente c칩digo es una de muchas opciones.

```{r}
#| label: fig-violin-ej6
#| fig-cap: Resultado del ejercicio 6
violin_ej5_gg +
    geom_boxplot(
        fill     = "transparent",
        outliers = FALSE,
        varwidth = TRUE,
        width    = .2
    ) +
    geom_point(
        stat  = "summary",
        fun   = "mean",
        shape = 19,
        size  = 3,
        color = "red"
    )
```
:::

Enhorabuena! Has llegado al final de la secci칩n de distribuciones. En la siguiente secci칩n vamos a ver c칩mo podemos comparar distribuciones entre diferentes grupos.

## Resumen

En esta secci칩n hemos aprendido a visualizar la distribuci칩n de una variable num칠rica utilizando distintos tipos de gr치ficos. Hemos visto c칩mo crear histogramas, gr치ficos de densidad, *boxplots* y *violin plots*. Adem치s, hemos aprendido a a침adir capas de puntos a los gr치ficos para ver la distribuci칩n de los datos, res칰menes estad칤sticos como la media y a modificar distintos argumentos de las geometr칤as.
