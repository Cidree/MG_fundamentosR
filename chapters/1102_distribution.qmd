---
execute: 
  warning: false
editor_options: 
  chunk_output_type: console
filters: 
    - webr
webr:
    packages: ["dplyr", "ggplot2"]
---

# Gr√°ficos de distribuci√≥n {#sec-plot-distribution}

Los gr√°ficos de distribuci√≥n son una forma de visualizar la distribuci√≥n de los datos. En este tipo de gr√°ficos, se muestra la frecuencia de los valores de una variable o de un conjunto de variables. Los gr√°ficos de distribuci√≥n son √∫tiles para identificar patrones en los datos, como la presencia de valores at√≠picos, la simetr√≠a de la distribuci√≥n, la presencia de m√∫ltiples modas, entre otros. Generalmente, los gr√°ficos de distribuci√≥n se utilizan para visualizar **una sola variable num√©rica** aunque en la @fig-vis-classification se muestra que tambi√©n es posible visualizar **dos variables num√©ricas** mediante el uso de gr√°ficos de dispersi√≥n (**scatter plot**).

En este cap√≠tulo, veremos los siguientes tipos de gr√°ficos de distribuci√≥n:

1.  Histogramas (**histogram**)

2.  Gr√°ficos de densidad (**density plot**)

3.  Gr√°ficos de cajas (**box plot**)

4.  Gr√°ficos de viol√≠n (**violin plot**)

::: callout-info
Los gr√°ficos de dispersi√≥n los veremos dentro del cap√≠tulo de gr√°ficos de relaci√≥n.
:::

En este cap√≠tulo vamos a trabajar con dos datasets:

-   `iris`: se utilizar√° para los ejemplos utilizados en las explicaciones (ver [Tipos de visualizaci√≥n](#sec-visualization-types){target="_blank"}).

-   `inventario`: ser√°n los datos que utilizar√°n los alumnos para los ejercicios propuestos (ver @sec-vis-data).

Para comenzar, vamos a cargar los paquetes necesarios y a leer los datos que utilizaremos en este cap√≠tulo.

```{r}
#| include: false
## Paquetes internos
library(patchwork)
```

```{r}
# Cargar paquetes
library(dplyr)
library(readr)
library(ggplot2)
# Cargar datos
inventario_tbl <- read_rds("../data/inventario_prep.rds")
```

## Objetivos

Al final de este cap√≠tulo, ser√°s capaz de:

-   Utilizar etiquetas y temas predise√±ados en `{ggplot2}`

-   Crear histogramas en `{ggplot2}`

-   Crear gr√°ficos de densidad en `{ggplot2}`

-   Crear gr√°ficos de cajas en `{ggplot2}`

-   Crear gr√°ficos de viol√≠n en `{ggplot2}`

-   A√±adir l√≠neas a los gr√°ficos

-   A√±adir puntos con res√∫menes estad√≠sticos a los gr√°ficos

## Histogramas

Los histogramas son una forma de visualizar la distribuci√≥n de una variable num√©rica. En un histograma, los valores de la variable se agrupan en intervalos y se muestra la frecuencia de los valores en cada intervalo. Los histogramas son √∫tiles para identificar la forma de la distribuci√≥n de los datos, la presencia de valores at√≠picos y la presencia de m√∫ltiples modas.

Para crear un histograma en `ggplot2`, utilizamos la funci√≥n `geom_histogram()`. Tiene dos argumentos de gran importancia:

-   `bins`: n√∫mero de intervalos en los que se agrupar√°n los datos. Si no se especifica, `{ggplot2}` utilizar√° 30 intervalos.

-   `binwidth`: ancho de los intervalos. Si se especifica, `{ggplot2}` calcular√° el n√∫mero de intervalos autom√°ticamente.

::: callout-note
Estos dos argumentos son mutuamente excluyentes. Si se especifica `bins`, `{ggplot2}` ignorar√° `binwidth`.
:::

Vamos a ver la diferencia entre estos dos argumentos viendo la distribuci√≥n de la longitud de los p√©talos de las flores del dataset `iris`:

::: panel-tabset
## N√∫mero de intervalos

Al especificar el n√∫mero de intervalos lo que hacemos es b√°sicamente indicar el n√∫mero de barras que queremos generar:

```{shinylive-r}
#| standalone: true
#| viewerHeight: 600

## Load packages
library(bslib)
library(ggplot2)
library(glue)
library(shiny)

## UI
ui <- page_sidebar(
    sidebar = sidebar(
        open = "open",
        width = 200,
        sliderInput("bins", "N√∫mero de intervalos", min = 1, max = 30, value = 15),
    ),
    verbatimTextOutput("code") |> card(),
    plotOutput("plot", width = 500) |> card()
)

## Server
server <- function(input, output, session) {
    
    output$code <- renderPrint({
        glue(
            'ggplot(iris, aes(x = Petal.Length)) +
                    geom_histogram(bins = {input$bins}, fill = "#0073C2FF", color = "white") +
                    labs(
                        title = "Distribuci√≥n de longitud del p√©talo", 
                        x = "Longitud (mm)", 
                        y = "Frecuencia"
                    )'
            )
    })

    ## Plot
    output$plot <- renderPlot({
        ggplot(iris, aes(x = Petal.Length)) +
            geom_histogram(bins = input$bins, fill = "#0073C2FF", color = "white") +
            labs(
                title = "Distribuci√≥n de longitud del p√©talo", 
                x = "Longitud (cm)", 
                y = "Frecuencia"
            ) +
            theme_gray(base_size = 8)
    }, res = 96)
}

## Run app
shinyApp(ui = ui, server = server)
```

## Ancho del intervalo

Cuando seleccionamos el ancho del intervalo (*binwidth*), estamos seleccionando el tama√±o del intervalo en las unidades de la variable que estamos evaluando. Por ejemplo, si seleccionamos un ancho de banda de 0.3 para la longitud del p√©talo, estamos indicando que cada barra agrupar√° observaciones de 3 en 3 mil√≠metros. De 0-0.3 tendremos el primer intervalo, de 0.3-0.6 el segundo, y as√≠ sucesivamente.

```{shinylive-r}
#| standalone: true
#| viewerHeight: 600

## Load packages
library(bslib)
library(ggplot2)
library(glue)
library(shiny)

## UI
ui <- page_sidebar(
    sidebar = sidebar(
        open = "open",
        width = 200,
        sliderInput("bins", "Ancho del intervalo", min = 0.1, max = 2, value = .2, step = .1),
    ),
    verbatimTextOutput("code") |> card(),
    plotOutput("plot", width = 500) |> card()
)

## Server
server <- function(input, output, session) {
    
    output$code <- renderPrint({
        glue(
            '
            ggplot(iris, aes(x = Petal.Length)) +
                    geom_histogram(binwidth = {input$bins}, fill = "#0073C2FF", color = "white") +
                    labs(
                        title = "Distribuci√≥n de longitud del p√©talo", 
                        x = "Longitud (mm)", 
                        y = "Frecuencia"
                    )'
            )
    })

    ## Plot
    output$plot <- renderPlot({
        ggplot(iris, aes(x = Petal.Length)) +
            geom_histogram(binwidth = input$bins, fill = "#0073C2FF", color = "white") +
            labs(
                title = "Distribuci√≥n de longitud del p√©talo", 
                x     = "Longitud (mm)", 
                y     = "Frecuencia"
            ) +
            theme_gray(base_size = 8)
    }, res = 96)
}

## Run app
shinyApp(ui = ui, server = server)
```
:::

::: callout-tip
Los c√≥digos hexadecimales son una forma de representar colores en HTML y CSS. En R, podemos utilizarlos para cambiar el color de los gr√°ficos. En este caso, el color `#0073C2FF` representa un azul claro. Puedes utilizar generadores de colores online como [este](https://htmlcolorcodes.com/){target="_blank"} para elegir un color.
:::

Un histograma es b√°sicamente esto. Para el color de relleno utilizamos el argumento `fill` y para el color del contorno utilizamos el argumento `color`, y este patr√≥n seguir√° siendo el mismo para los otros tipos de gr√°ficos de `{ggplot2}`.

Tambi√©n te habr√°s dado cuenta que hemos a√±adido una funci√≥n nueva que es `labs()`. Esta funci√≥n nos permite a√±adir etiquetas al gr√°fico como:

-   `title`: t√≠tulo del gr√°fico.

-   `subtitle`: subtitulo del gr√°fico.

-   `x`: t√≠tulo del eje x.

-   `y`: t√≠tulo del eje y.

-   `caption`: pie de figura.

Si bien es cierto que los histogramas son una forma de visualizar la distribuci√≥n de una sola variable, tambi√©n podemos crear histogramas para comparar la distribuci√≥n de una variable num√©rica entre diferentes grupos. Esto puede ser muy conveniente, ya que si nos fijamos en las figuras anteriores, podemos ver que si indicamos el n√∫mero de intervalos adecuado sigue una [distribuci√≥n bimodal](#0){target="_blank"}.

Vamos a ver qu√© pasa si comparamos la distribuci√≥n de la longitud de los p√©talos de las flores del *dataset* `iris` entre las diferentes especies de flores. Para ello, utilizamos el argumento `fill` en la funci√≥n `aes()` para indicar la variable categ√≥rica que queremos comparar:

```{r}
#| label: fig-distribution-species
#| fig-cap: Distribuci√≥n de longitud del p√©talo por especie

iris |> 
    ggplot(
        aes(x = Petal.Length, fill = Species)
    ) +
    geom_histogram(bins = 30, color = "white") +
    labs(
        title    = "Distribuci√≥n de longitud del p√©talo por especie", 
        subtitle = "La especie I. setosa tiene una longitud de p√©talo menor que I. versicolor e I. virginica",
        x        = "Longitud (mm)", 
        y        = "Frecuencia",
        caption  = "Autor: Adri√°n Cidre"
    ) +
    theme_minimal()
```

Ah√° ü§î! Gracias a utilizar una est√©tica m√°s podemos ver que la distribuci√≥n no es bimodal, si no que son distribuciones de especies de flores distintas. En esencia, a√±adir una est√©tica m√°s puede ser visto como a√±adir una dimensi√≥n m√°s al gr√°fico.

::: callout-note
A partir de ahora vamos a ir a√±adiendo nuevas funciones y argumentos a nuestros gr√°ficos. No te preocupes si no entiendes todo a la primera, poco a poco iremos viendo c√≥mo se utilizan y para qu√© sirven. En este caso hemos a√±adido `theme_minimal()` que nos permite cambiar el tema base del gr√°fico. Existen una serie de temas predefinidos que empiezan por `theme_*()`.
:::

## Gr√°ficos de densidad

Los gr√°ficos de densidad son una forma de visualizar la distribuci√≥n de una variable num√©rica. A diferencia de los histogramas, los gr√°ficos de densidad no agrupan los datos en intervalos, sino que muestran la estimaci√≥n de densidad kernel de los datos. Los gr√°ficos de densidad son √∫tiles para identificar la forma de la distribuci√≥n de los datos, ya que son una versi√≥n suavizada de los histogramas.

Para crear un gr√°fico de densidad en `{ggplot2}`, utilizamos la funci√≥n `geom_density()`. B√°sicamente, se va a generar una l√≠nea que nos va a indicar la densidad de probabilidad de los datos. Como es una l√≠nea, tiene una serie de est√©ticas que podemos modificar a continuaci√≥n:

```{shinylive-r}
#| standalone: true
#| viewerHeight: 600

## Load packages
library(bslib)
library(ggplot2)
library(glue)
library(shiny)

## UI
ui <- page_sidebar(
    sidebar = sidebar(
        open  = "open",
        width = 200,
        selectInput(
            inputId  = "linetype_input",
            label    = "Linetype",
            choices  = c("solid", "dashed", "dotted",
                         "dotdash", "longdash", "twodash"),
            selected = "solid"
        ),
        sliderInput(
            inputId = "linewidth_input",
            label   = "Linewidth",
            min     = 0,
            max     = 4,
            value   = 1,
            step    = .5
        ),
        checkboxInput(
            inputId = "fill_input",
            label   = "Rellenar?",
            value   = FALSE
        )
    ),
    verbatimTextOutput("code") |> card(),
    plotOutput("plot", width = 500) |> card()
)

## Server
server <- function(input, output, session) {
    
    output$code <- renderPrint({
        
        if (input$fill_input) {
            glue(
            'ggplot(iris, aes(x = Petal.Length)) +
                geom_density(
                    color     = "darkred",
                    fill      = "gray30",
                    linetype  = "{input$linetype_input}",
                    linewidth = {input$linewidth_input}
                ) +
                labs(
                    title = "Distribuci√≥n de longitud del p√©talo", 
                    x     = "Longitud (mm)", 
                    y     = "Probabilidad (%)"
                ) +
                theme_bw(base_size = 8)'
            )
        } else {
            glue(
            'ggplot(iris, aes(x = Petal.Length)) +
                geom_density(
                    color     = "darkred",
                    linetype  = "{input$linetype_input}",
                    linewidth = {input$linewidth_input}
                ) +
                labs(
                    title = "Distribuci√≥n de longitud del p√©talo", 
                    x     = "Longitud (mm)", 
                    y     = "Probabilidad (%)"
                ) +
                theme_bw()'
            )
        }
    })

    ## Plot
    output$plot <- renderPlot({
        ggplot(iris, aes(x = Petal.Length)) +
            geom_density(
                color     = "darkred",
                linetype  = input$linetype_input,
                linewidth = input$linewidth_input,
                fill      = if (input$fill_input) "gray30" else NA
            ) +
            labs(
                title = "Distribuci√≥n de longitud del p√©talo", 
                x     = "Longitud (mm)", 
                y     = "Probabilidad (%)"
            ) +
            theme_bw(base_size = 8)
    }, res = 96)
}

## Run app
shinyApp(ui = ui, server = server)
```

### Ejercicio 1

Finalmente, al igual que con los histogramas, podemos comparar la distribuci√≥n de la longitud del p√©talo entre las diferentes especies de flores del *dataset* `iris`. Te atreves a intentar a√±adir la parte del c√≥digo que falta? El resultado deber√≠a ser el indicado en la @fig-distribution-ej1:

::: panel-tabset
## Gr√°fico esperado

Intenta replicar este gr√°fico en la pesta√±a "Ejercicio"

```{r}
#| label: fig-distribution-ej1
#| fig-cap: Resultado esperado del ejercicio 1
#| echo: false
iris |> 
    ggplot(aes(x = Petal.Length)) +
    geom_density(
        aes(fill = Species),
        color    = NA,
        alpha    = .8
    ) +
    labs(
        title = "Distribuci√≥n de longitud del p√©talo",
        x     = "Longitud (mm)", 
        y     = "Probabilidad (%)"
    ) +
    theme_bw()
```

## Ejercicio

En total hay que a√±adir tres elementos:

-   Transparencia (necesaria para poder ver la superposici√≥n de densidades)

-   Eliminar color de contorno

-   Crear un gr√°fico de densidad por especie dentro del mismo gr√°fico

```{webr-r}
iris |> 
    ggplot(
        aes(x = Petal.Length)
    ) +
    geom_density() +
    labs(
        title = "Distribuci√≥n de longitud del p√©talo",
        x     = "Longitud (mm)", 
        y     = "Probabilidad (%)"
    ) +
    theme_bw()
```

## Soluci√≥n

El argumento `aes(fill = Species)` tambi√©n se puede introducir en la funci√≥n `ggplot()`.

```{r}
#| label: fig-distribution-ej1-sol
#| fig-cap: Resultado del ejercicio 1
iris |> 
    ggplot(aes(x = Petal.Length)) +
    geom_density(
        aes(fill = Species),
        color    = NA,
        alpha    = .8
    ) +
    labs(
        title = "Distribuci√≥n de longitud del p√©talo",
        x     = "Longitud (mm)", 
        y     = "Probabilidad (%)"
    ) +
    theme_bw()

```
:::

### Ejercicio 2

En los siguientes ejercicios vamos a trabajar con los datos de inventario. Vamos a empezar cargando los datos, convertirlos a `tibble` y vamos a ver de nuevo su estructura:

```{webr-r}
## Url de los datos
url <- "https://cidree.github.io/MG_datasets/inventario_prep.csv"
inventario_tbl <- read.csv(url) |> as_tibble()
## Estructura datos
inventario_tbl
```

El ejercicio consiste en generar un histograma de la distribuci√≥n diam√©trica (en cent√≠metros), adem√°s generando un gr√°fico por especie. Utiliza el siguiente bloque de c√≥digo y practica todo lo que hemos visto hasta ahora:

::: panel-tabset
## Ejercicio 2

```{webr-r}
## Escribir c√≥digo aqu√≠

```

## Resultado

El siguiente c√≥digo es una de muchas opciones.

```{r}
#| label: fig-distribution-ej2
#| fig-cap: Resultado del ejercicio 2
inventario_tbl |> 
    ggplot(
        aes(x = dbh_mm / 10, fill = nombre_ifn)
    ) +
    geom_histogram(
        bins  = 25, 
        color = "snow"
    ) +
    labs(
        title = "Distribuci√≥n diam√©trica por especie",
        x     = "Di√°metro (cm)", 
        y     = "Frecuencia",
        fill  = "Especie"
    ) +
    theme_minimal()
```
:::

En la @fig-distribution-ej2 hemos a√±adido el argumento `fill` dentro de la funci√≥n `labs()`. Cuando utilizamos una est√©tica como color, fill, shape... dentro de `aes()`, podemos utilizar el nombre de esta est√©tica dentro de `labs()` para modificar el t√≠tulo de la leyenda.

### Ejercicio 3

Generar un gr√°fico de densidad para la altura de los √°rboles por especie.

::: panel-tabset
## Ejercicio 3

```{webr-r}
## Escribir c√≥digo aqu√≠

```

## Resultado

El siguiente c√≥digo es una de muchas opciones.

```{r}
#| label: fig-distribution-ej3
#| fig-cap: Resultado del ejercicio 3
inventario_tbl |> 
    ggplot(
        aes(x = height_m, fill = nombre_ifn)
    ) +
    geom_density(
        alpha = .7
    ) +
    labs(
        title = "Distribuci√≥n de alturas por especie",
        x     = "Altura (m)", 
        y     = "Probabilidad (%)",
        fill  = "Especie"
    ) +
    theme_minimal()
```
:::

### Extra - A√±adir l√≠neas

Algo com√∫n es a√±adir l√≠neas a los gr√°ficos que representen alg√∫n valor importante como la media o la mediana. En esta breve secci√≥n vamos a ver como a√±adir estas dos l√≠neas a un histograma.

Vamos a empezar con un histograma de la distribuci√≥n diam√©trica de *P. sylvestris*:

```{r}
#| label: fig-distribution-ps
#| fig-cap: Distribuci√≥n diam√©trica de *Pinus sylvestris*
inventario_tbl |> 
    filter(nombre_ifn == "Pinus sylvestris") |> 
    ggplot(
        aes(x = dbh_mm)
    ) +
    geom_histogram(
        color = "snow",
        fill  = "#0073C2FF"
    ) +
    theme_bw()
```

La idea es a√±adir una **l√≠nea vertical** que nos se√±ale donde se encuentran la media y la mediana. Para ello, tenemos la funci√≥n `geom_vline()`. El argumento m√°s importante es:

-   `xintercept`: valor en el eje x donde se va a situar la l√≠nea.

El resto de argumentos pueden consultarse en la documentaci√≥n de la funci√≥n, y ser√°n los comunes a geometr√≠as de l√≠nea: *color, linewidth, linetype...*

```{r}
#| label: fig-distribution-ps-lines
#| fig-cap: Distribuci√≥n diam√©trica de *Pinus sylvestris* con l√≠neas
## Filtrar datos de Pinus sylvestris
## Crear columna de di√°metro en cm
psylvestris_tbl <- inventario_tbl |> 
    filter(nombre_ifn == "Pinus sylvestris") |> 
    mutate(
        dbh_cm = dbh_mm / 10
    )
    
## Gr√°fico
psylvestris_tbl |> 
    ggplot(
        aes(x = dbh_cm)
    ) +
    geom_histogram(
        color = "snow",
        fill  = "#0073C2FF",
        alpha = .7  
    ) +
    geom_vline(
        aes(xintercept = mean(psylvestris_tbl$dbh_cm, na.rm = TRUE)),
        color = "darkred",
        size  = 1
    ) +
    geom_vline(
        xintercept = median(psylvestris_tbl$dbh_cm, na.rm = TRUE),
        color      = "darkorange",
        size       = 1
    ) +
    labs(
        title = "Distribuci√≥n diam√©trica de Pinus sylvestris",
        x     = "Di√°metro (cm)", 
        y     = "Frecuencia"
    ) +
    theme_bw()

```

Como solamente utilizamos un valor que generamos con `mean()` y `median()`, no es necesario utilizar `aes()` en `geom_vline()`. Se muestran ambas opciones para mostrar que es posible utilizar cualquiera de las dos opciones.

## Boxplot

Los *boxplot* (gr√°ficos de cajas o bigotes) son una forma de visualizar la distribuci√≥n de una variable num√©rica. En un gr√°fico de cajas, se muestra un resumen de la distribuci√≥n de los datos, incluyendo la mediana, los cuartiles y los valores at√≠picos. Los gr√°ficos de cajas son √∫tiles para identificar la presencia de valores at√≠picos y la simetr√≠a de la distribuci√≥n.

![Partes de un boxplot. Fuente: [R Graph Gallery](https://r-graph-gallery.com/boxplot.html){target="_blank"}](/images/boxplot.png){#fig-boxplot-explanation fig-align="center"}

Aunque es un gr√°fico que nos da un resumen estad√≠stico muy bueno, es un gr√°fico que **nunca** se debe utilizar solo. Un boxplot nos est√° mostrando cinco valores principales: m√≠nimo, primer cuartil, mediana, tercer cuartil y m√°ximo. Sin embargo, no sabemos nada del resto de valores. F√≠jate en los siguientes boxplot:

```{r}
#| label: fig-boxplot-ex
#| fig-cap: Boxplots con datos ficticios con la misma forma
#| echo: false
## Crear valores
set.seed(123)
rand_vals <- sample(1:100, 500, replace = TRUE)
## Crear boxplot
g1 <- data.frame(x = rand_vals, y = "A") |> 
    ggplot(
        aes(x = y, y = x)
    ) +
    geom_boxplot() +
    geom_jitter(
        alpha = .3,
        position = position_jitter(height = 0)
    ) +
    labs(
        title = "Boxplot 1",
        x     = NULL, 
        y     = NULL
    ) +
    theme_minimal()

## Valores resumen
summary_vals <- data.frame(
    y = c(
        min(rand_vals, na.rm = TRUE) |> rep(20),
        quantile(rand_vals, .25, na.rm = TRUE) |> rep(20),
        median(rand_vals, na.rm = TRUE) |> rep(20),
        quantile(rand_vals, .75, na.rm = TRUE) |> rep(20),
        max(rand_vals, na.rm = TRUE) |> rep(20)
    ),
    x = "A"
)

## Crear boxplot
g2 <- summary_vals |> 
    ggplot(
        aes(x = x, y = y)
    ) +
    geom_boxplot() +
    geom_jitter(alpha = .3, position = position_jitter(height = 0)) +
    labs(
        title = "Boxplot 2",
        x     = NULL, 
        y     = NULL
    ) +
    theme_minimal()

## Visualizar 
g1 + g2
```

Ambos gr√°ficos tienen exactamente la misma forma, pero como puedes ver en los puntos, los datos son muy distintos. Es por ello que se suelen utilizar variantes del *boxplot* o el *boxplot* combinado con otras geometr√≠as como el *violin plot*.

Una vez vista esta debilidad de los *boxplot*, vamos a generar uno para la distribuci√≥n de la longitud de los p√©talos del *dataset* de iris. En este caso, va a ser el primer gr√°fico de distribuci√≥n donde utilicemos ambas est√©ticas de los ejes `x` e `y`.

La funci√≥n `geom_boxplot()` tiene un mont√≥n de argumentos que podemos modificar. Los *outliers* se representan como puntos, y por ende, podemos modificar todo aquello relacionado con ellos con argumentos que empiezan por `outlier.*`. Por ejemplo, `outlier.shape`, `outlier.size`, `outlier.color`...

```{r}
#| label: fig-boxplot-petal
#| fig-cap: Boxplot de la longitud del p√©talo
base_boxplot <- iris |> 
    ggplot(
        aes(x = Species, y = Petal.Length)
    ) +
    geom_boxplot(
        fill          = "orangered",
        alpha         = .4,
        outlier.shape = 21,
        outlier.size  = 3,
        outlier.color = "black",
        varwidth      = TRUE
    ) +
    labs(
        title = "Distribuci√≥n de la longitud del p√©talo por especie",
        x     = "Especie", 
        y     = "Longitud (mm)"
    ) +
    theme_minimal()
    
base_boxplot
```

Hemos guardo el gr√°fico en un objeto llamado `base_boxplot` para poder a√±adir m√°s elementos en la siguiente secci√≥n.

### Boxplot + Jitter

Para a√±adir la distribuci√≥n de los datos en un boxplot, podemos utilizar la funci√≥n `geom_point()`:

```{r}
#| label: fig-boxplot-petal-point
#| fig-cap: Boxplot de la longitud del p√©talo con geom_point()
base_boxplot +
    geom_point()
```

Sin embargo, como puedes ver, los puntos est√°n superpuestos. Para evitar esto, podemos utilizar la funci√≥n `position_jitter()` dentro del argumento `position` que nos permite a√±adir un poco de ruido a los puntos para que no se superpongan. Esto significa que los puntos tendr√°n un determinando porcentaje (0-1) de variaci√≥n en el eje `x` con el argumento `width` y en el eje `y` con el argumento `height`. Utiliza la siguiente herramienta para ver como funciona:

```{shinylive-r}
#| standalone: true
#| viewerHeight: 600

## Load packages
library(bslib)
library(ggplot2)
library(glue)
library(shiny)

## UI
ui <- page_sidebar(
    sidebar = sidebar(
        open = "open",
        width = 200,
        sliderInput("width_j", "Width", min = 0, max = 1, value = .5, step = .1),
        sliderInput("height_j", "Height", min = 0, max = 1, value = .5, step = .1)
    ),
    verbatimTextOutput("code") |> card(),
    plotOutput("plot", width = 500) |> card()
)

## Server
server <- function(input, output, session) {
    
    output$code <- renderPrint({
        glue(
            '
            base_boxplot +
                geom_point(
                    position = position_jitter(
                        width  = {input$width_j},
                        height = {input$height_j}
                    ),
                    alpha    = .7
                )'
            )
    })

    ## Plot
    output$plot <- renderPlot({
        ggplot(iris, aes(x = Species, y = Petal.Length)) +
            geom_boxplot(
                fill          = "orangered",
                alpha         = .4,
                outlier.shape = 21,
                outlier.size  = 3,
                outlier.color = "black",
                varwidth      = TRUE
            ) +
            labs(
                title = "Distribuci√≥n de la longitud del p√©talo por especie",
                x     = "Especie", 
                y     = "Longitud (mm)"
            ) +
            theme_minimal() +
                        geom_point(
                            position = position_jitter(
                                width  = {input$width_j},
                                height = {input$height_j}
                            ),
                            alpha    = .7
                        ) +
                    theme_gray(base_size = 8)
    }, res = 96)
}

## Run app
shinyApp(ui = ui, server = server)
```

Si ambos son igual a 0, significa que no se a√±ade ruido. si aumentamos `width`, veremos que los datos se mantienen en sus valores originales seg√∫n la variable de longitud del p√©talo, pero se mueven aleatoriamente a lo largo del eje `x`. De este modo podemos ver mejor la distribuci√≥n. No obstante, esto es recomendable solamente en variables categ√≥ricas para que los puntos no est√©n unos encima de otros. En variables num√©ricas no tiene sentido ya que estamos modificando los datos. Es decir, en este ejemplo `height` debe ser igual a 0.

::: callout-note
Si utilizamos un valor igual o superior a 0.5 los puntos de distintas categor√≠as se superpondr√°n.
:::

Como esta geometr√≠a es muy com√∫n, `{ggplot2}` tiene la funci√≥n `geom_jitter()` que es un atajo para `geom_point(position = position_jitter())`:

```{r}
#| label: fig-boxplot-petal-jitter
#| fig-cap: Boxplot de la longitud del p√©talo con geom_jitter()
base_boxplot +
    geom_jitter(height = 0, width = .2)
```

### Ejercicio 4

Generar un *boxplot* de la distribuci√≥n diam√©trica por especie. Adem√°s, a√±adir la distribuci√≥n de los puntos. Para practicar, utiliza la documentaci√≥n de `geom_boxplot()` para modificar distintos argumentos.

::: panel-tabset
## Ejercicio 4

```{webr-r}
## Escribir c√≥digo aqu√≠

```

## Resultado

El siguiente c√≥digo es una de muchas opciones.

```{r}
#| label: fig-boxplot-ej4
#| fig-cap: Resultado del ejercicio 4

## Crear boxplot
inventario_tbl |> 
    ggplot(
        aes(x = nombre_ifn, y = dbh_mm / 10)
    ) +
    geom_boxplot(
        fill          = "#82BE1F",
        outlier.shape = 21,
        outlier.size  = 3,
        outlier.fill  = "#E121DB",
        varwidth      = TRUE,
        width         = .5
    ) +
    geom_jitter(
        color = "#7D9E69",
        height = 0,
        width  = .4,
        alpha  = .3
    ) +
    labs(
        title = "Distribuci√≥n diam√©trica por especie",
        x     = "Especie", 
        y     = "Di√°metro (cm)"
    ) +
    theme_minimal()
```
:::

### Extra - A√±adir media

Tambi√©n es posible a√±adir la localizaci√≥n de la media mediante un punto en un *boxplot*. Para ello, utilizamos la funci√≥n `geom_point()`:

```{r}
base_boxplot +
    geom_point()
```

Bueeeno üòÖ... Recuerdas cu√°ndo habl√°bamos de las transformaciones estad√≠sticas en @sec-components? Pues por defecto `geom_point()` utiliza `stat = "identity"`, que quer√≠a decir que no se aplica ninguna transformaci√≥n, y por lo tanto $f(x) = x$. Ser√° `{ggplot2}` tan m√°gico que nos dejar√° decir que realice una transformaci√≥n estad√≠stica en la que convierta los puntos a la media? S√≠, pero debemos utilizar la transformaci√≥n estad√≠stica `summary`, y elegir una funci√≥n de resumen con el argumento `fun`. En realidad, podemos a√±adir varias funciones que puedes probar aqu√≠:

```{shinylive-r}
#| standalone: true
#| viewerHeight: 600

## Load packages
library(bslib)
library(ggplot2)
library(glue)
library(shiny)

## UI
ui <- page_sidebar(
    sidebar = sidebar(
        open = "open",
        width = 200,
        selectInput(
            inputId = "fun_input", 
            label   = "Funci√≥n", 
            choices = c("min", "max", "mean", "median", "quantile")
        )
    ),
    verbatimTextOutput("code") |> card(),
    plotOutput("plot", width = 500) |> card()
)

## Server
server <- function(input, output, session) {
    
    output$code <- renderPrint({
        glue(
            '
            base_boxplot +
                geom_point(
                    stat  = "summary",
                    fun   = {input$fun_input},
                    shape = 4,
                    size  = 3,
                    color = "red"
                )'
            )
    })

    ## Plot
    output$plot <- renderPlot({
        ggplot(iris, aes(x = Species, y = Petal.Length)) +
            geom_boxplot(
                fill          = "orangered",
                alpha         = .4,
                outlier.shape = 21,
                outlier.size  = 3,
                outlier.color = "black",
                varwidth      = TRUE
            ) +
            labs(
                title = "Distribuci√≥n de la longitud del p√©talo por especie",
                x     = "Especie", 
                y     = "Longitud (mm)"
            ) +
            theme_minimal() +
            geom_point(
                stat  = "summary",
                fun   = {input$fun_input},
                shape = 4,
                size  = 3,
                color = "red"
            ) +
            theme_gray(base_size = 8)
    }, res = 96)
}

## Run app
shinyApp(ui = ui, server = server)
```

Cualquier funci√≥n que se pueda aplicar a un vector num√©rico, se puede a√±adir dentro del argumento `fun`, y esto incluye funciones personalizadas.

::: callout-tip
Si quieres ver las opciones del argumento `shape`, puedes consultar la documentaci√≥n de la funci√≥n `points()`.

![Opciones de puntos para el argumento \`shape\`](/images/point-shape.png){#fig-point-shapes fig-align="center"}
:::

## Violin plot

El *violin plot* es una forma de visualizar la distribuci√≥n de una variable num√©rica. A diferencia del *boxplot*, el *violin plot* muestra la distribuci√≥n de los datos de forma m√°s detallada, de forma que no es necesario a√±adir una capa de puntos **jitter** para tener una idea de la distribuci√≥n de los datos.

```{r}
#| label: fig-violin-petal
#| fig-cap: Violin plot de la longitud del p√©talo
base_violin <- iris |> 
    ggplot(
        aes(x = Species, y = Petal.Length)
    ) +
    geom_violin(
        fill  = "#0073C2FF",
        color = "white"
    ) +
    labs(
        title = "Distribuci√≥n de la longitud del p√©talo por especie",
        x     = "Especie", 
        y     = "Longitud (mm)"
    ) +
    theme_minimal()
  
base_violin
```

En la @fig-violin-petal vemos que los gr√°ficos son m√°s o menos anchos. Cuanto m√°s anchos, m√°s datos hay en esa zona. Para tener una idea de lo que significa, podemos a√±adir una capa de puntos y as√≠ entenderlo mejor:

```{r}
#| label: fig-violin-petal-jitter
#| fig-cap: Violin plot de la longitud del p√©talo con `geom_jitter()`
base_violin +
  geom_jitter(
      alpha  = .5,
      height = 0
  ) 
```

Como puedes ver, los puntos se distribuyen en funci√≥n de la anchura del *violin plot*. Si la anchura es mayor, significa que hay m√°s datos en esa zona.

Opciones interesantes para modificar el *violin plot* son:

-   `trim`: si es `FALSE`, el *violin plot* se extender√° hasta los valores extremos de los datos. Si es `TRUE` (por defecto), se extender√° hasta el valor m√°s extremo que no sea un valor at√≠pico.

-   `scale`: si es `area` (por defecto), el √°rea de cada *violin* es proporcional al n√∫mero de observaciones. Si es `count`, el ancho de cada *violin* es proporcional al n√∫mero de observaciones.

-   `draw_quantiles`: si es `TRUE`, se dibujar√°n los cuantiles del 25%, 50% y 75% en el *violin plot*.

```{r}
#| label: fig-violin-petal-options
#| fig-cap: Violin plot de la longitud del p√©talo con opciones
iris |> 
    ggplot(
        aes(x = Species, y = Petal.Length)
    ) +
    geom_violin(
        fill  = "#0073C2FF",
        color = "white",
        trim  = TRUE,
        scale = "area",
        draw_quantiles = c(.25, .5, .75),
    ) +
    labs(
        title = "Distribuci√≥n de la longitud del p√©talo por especie",
        x     = "Especie", 
        y     = "Longitud (mm)"
    ) +
    theme_minimal()
```

### Ejercicio 5 {#sec-ej5}

Generar un *violin plot* de la distribuci√≥n diam√©trica por especie de `inventario_tbl`. Adem√°s, a√±adir una capa de puntos para ver la distribuci√≥n de los datos. Visualizar la diferencia entre `scale = "area"` y `scale = "count"` y quedarse con el que te parezca m√°s adecuado (en la pesta√±a "Resultado" se explica cu√°l es la mejor opci√≥n).

El resultado de este ejercicio lo utilizaremos en @sec-ej6, as√≠ que guarda el *violin plot* en un objeto llamado `violin_ej5_gg`.

::: panel-tabset
## Ejercicio 5

```{webr-r}
## Escribir c√≥digo aqu√≠
```

## Resultado

El siguiente c√≥digo es una de muchas opciones.

Con `scale = "count"`, vemos que de *P. sylvestris* tenemos muchos m√°s datos. Si utilizamos `scale = "area`, esto no lo sabemos. Por lo tanto, es mejor utilizar `scale = "count"`.

```{r}
#| label: fig-violin-ej5
#| fig-cap: Resultado del ejercicio 5
## Crear violin plot
violin_ej5_gg <- inventario_tbl |> 
    ggplot(
        aes(x = nombre_ifn, y = dbh_mm / 10)
    ) +
    geom_violin(
        fill  = "#82BE1F",
        color = "transparent",
        trim  = TRUE,
        scale = "count"
    ) +
    labs(
        title = "Distribuci√≥n diam√©trica por especie",
        x     = "Especie", 
        y     = "Di√°metro (cm)"
    ) +
    theme_bw()
## Imprimir
violin_ej5_gg
```
:::

### Ejercicio 6 {#sec-ej6}

En la @sec-ej5 hemos generado un diam√©trica por especie que guardamos como `violin_ej5_gg`. A este gr√°fico, a√±adir un *boxplot* y un punto que represente la media de la distribuci√≥n.

::: panel-tabset
## Ejercicio 6

```{webr-r}
## Escribir c√≥digo aqu√≠
```

## Resultado

El siguiente c√≥digo es una de muchas opciones.

```{r}
#| label: fig-violin-ej6
#| fig-cap: Resultado del ejercicio 6
violin_ej5_gg +
    geom_boxplot(
        fill     = "transparent",
        outliers = FALSE,
        varwidth = TRUE,
        width    = .2
    ) +
    geom_point(
        stat  = "summary",
        fun   = "mean",
        shape = 19,
        size  = 3,
        color = "red"
    )
```
:::

Enhorabuena! Has llegado al final de la secci√≥n de distribuciones. En la siguiente secci√≥n vamos a ver c√≥mo podemos comparar distribuciones entre diferentes grupos.

## Resumen

En esta secci√≥n hemos aprendido a visualizar la distribuci√≥n de una variable num√©rica utilizando distintos tipos de gr√°ficos. Hemos visto c√≥mo crear histogramas, gr√°ficos de densidad, *boxplots* y *violin plots*. Adem√°s, hemos aprendido a a√±adir capas de puntos a los gr√°ficos para ver la distribuci√≥n de los datos, res√∫menes estad√≠sticos como la media y a modificar distintos argumentos de las geometr√≠as.
